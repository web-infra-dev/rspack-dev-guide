<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rspack Development Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="getting-started.html">Getting started</a></li><li class="chapter-item affix "><a href="about-this-guide.html">About this guide</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Development</li><li class="chapter-item "><a href="building/intro.html"><strong aria-hidden="true">1.</strong> Building and running</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/prerequisites.html"><strong aria-hidden="true">1.1.</strong> Prerequisites</a></li><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">1.2.</strong> Suggested Workflows</a></li></ol></li><li class="chapter-item "><a href="testing/intro.html"><strong aria-hidden="true">2.</strong> Testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/e2e.html"><strong aria-hidden="true">2.1.</strong> E2E</a></li></ol></li><li class="chapter-item "><a href="debugging/intro.html"><strong aria-hidden="true">3.</strong> Debugging</a></li><li class="chapter-item "><a href="profiling/intro.html"><strong aria-hidden="true">4.</strong> Profiling</a></li><li class="chapter-item "><a href="releasing/intro.html"><strong aria-hidden="true">5.</strong> Releasing</a></li><li class="chapter-item affix "><li class="part-title">Contribution</li><li class="chapter-item "><a href="contributing/intro.html"><strong aria-hidden="true">6.</strong> Contribution procedures</a></li><li class="chapter-item "><a href="contributing/repro.html"><strong aria-hidden="true">7.</strong> Minimal reproducible example</a></li><li class="chapter-item "><a href="contributing/team.html"><strong aria-hidden="true">8.</strong> About the team</a></li><li class="chapter-item "><a href="contributing/managing-labels.html"><strong aria-hidden="true">9.</strong> Managing labels</a></li><li class="chapter-item affix "><li class="part-title">Architecture</li><li class="chapter-item "><a href="architecture/rspack/intro.html"><strong aria-hidden="true">10.</strong> rspack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="architecture/rspack/loader.html"><strong aria-hidden="true">10.1.</strong> loader</a></li></ol></li><li class="chapter-item "><a href="architecture/webpack/intro.html"><strong aria-hidden="true">11.</strong> webpack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="architecture/webpack/loader.html"><strong aria-hidden="true">11.1.</strong> loader</a></li><li class="chapter-item "><a href="architecture/webpack/dependency.html"><strong aria-hidden="true">11.2.</strong> dependency</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">Workflows</li><li class="chapter-item "><a href="workflows/meetings.html"><strong aria-hidden="true">12.</strong> Meetings</a></li><li class="chapter-item "><a href="workflows/releases.html"><strong aria-hidden="true">13.</strong> Releases</a></li><li class="chapter-item "><a href="workflows/misc.html"><strong aria-hidden="true">14.</strong> Misc</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="appendix/learning-resources.html">Appendix A: Learning resources</a></li><li class="chapter-item affix "><a href="appendix/fun.html">Appendix Z: Fun stuff</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rspack Development Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>We are grateful for your interest in contributing to Rspack!
Every single contribution counts and helps us take Rspack to the next level.</p>
<ul>
<li><a href="getting-started.html#asking-questions">Asking Questions</a></li>
<li><a href="getting-started.html#what-should-i-work-on">What should I work on?</a>
<ul>
<li><a href="getting-started.html#good-first-issue">Good First Issue</a></li>
<li><a href="getting-started.html#tracking-issue">Tracking Issue</a></li>
</ul>
</li>
<li><a href="getting-started.html#other-ways-to-contribute">Other ways to contribute</a></li>
</ul>
<h2 id="asking-questions"><a class="header" href="#asking-questions">Asking Questions</a></h2>
<p>If you have any questions,
please do not hesitate to ask in either the <a href="https://discord.gg/79ZZ66GH9E">Discord</a> support channel or on the <a href="https://github.com/web-infra-dev/rspack/discussions">Github discussion board</a>.</p>
<h2 id="what-should-i-work-on"><a class="header" href="#what-should-i-work-on">What should I work on?</a></h2>
<h3 id="good-first-issue"><a class="header" href="#good-first-issue">Good First Issue</a></h3>
<p>If you are looking to dive into the codebase and get started,
we recommend checking out our issue list labeled with <a href="https://github.com/web-infra-dev/rspack/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22good+first+issue%22">good first issue</a>.
This will help you get acquainted with the project and start contributing.</p>
<h3 id="tracking-issue"><a class="header" href="#tracking-issue">Tracking Issue</a></h3>
<p>If you are interested in understanding our project's direction and want to work on issues that are aligned with our priorities,
our <a href="https://github.com/web-infra-dev/rspack/issues?q=is%3Aopen+label%3A%22tracking+issue%22+sort%3Aupdated-desc">tracking issues list</a>
provides an overview of our progress and current goals.</p>
<h2 id="other-ways-to-contribute"><a class="header" href="#other-ways-to-contribute">Other ways to contribute</a></h2>
<p>We are always looking for contributors, and that goes beyond just our main repository.
Check out these other ways to get involved and start making a difference today.</p>
<ul>
<li>The <a href="https://github.com/web-infra-dev/rspack-website">documentation website</a> is at <a href="https://github.com/web-infra-dev/rspack-website">web-infra-dev/rspack-website</a></li>
<li>This dev guide is at <a href="https://github.com/web-infra-dev/rspack-dev-guide">web-infra-dev/rspack-dev-guide</a></li>
<li>Community packages is at <a href="https://github.com/rspack-contrib">https://github.com/rspack-contrib</a></li>
</ul>
<hr />
<p>As a reminder, all contributors are expected to follow our <a href="https://github.com/web-infra-dev/rspack/blob/main/CODE_OF_CONDUCT.md">Code of Conduct</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-this-guide"><a class="header" href="#about-this-guide">About this guide</a></h1>
<p>This guide is meant to help document how Rspack works, as well as to help new contributors get involved in Rspack development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-and-run-the-compiler"><a class="header" href="#how-to-build-and-run-the-compiler">How to build and run the compiler</a></h1>
<p>Please see <a href="building/prerequisites.html">prerequisites</a> for setting up Rust and Node.js.</p>
<h2 id="install-nodejs-dependencies"><a class="header" href="#install-nodejs-dependencies">Install Node.js dependencies</a></h2>
<p>Install Node.js dependencies via <a href="https://pnpm.io/">pnpm</a>.</p>
<pre><code class="language-bash"># enable pnpm with corepack, only available on node &gt;= `v14.19.0`
corepack enable

# or install pnpm directly
npm install -g pnpm@7

# Install dependencies
pnpm install
</code></pre>
<h2 id="building-rspack"><a class="header" href="#building-rspack">Building Rspack</a></h2>
<ul>
<li>Run <code>cargo build</code> to compile Rust code.</li>
<li>Run <code>pnpm run build:cli:debug</code> to compile both Node.js and Rust code.</li>
</ul>
<p>The built binary is located at <code>packages/rspack-cli/bin/rspack</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<h2 id="setup-rust"><a class="header" href="#setup-rust">Setup Rust</a></h2>
<ul>
<li>Install Rust using <a href="https://rustup.rs/">rustup</a>.</li>
<li>If you are using VSCode, we recommend installing the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a> extension.</li>
</ul>
<h2 id="setup-nodejs"><a class="header" href="#setup-nodejs">Setup Node.js</a></h2>
<h3 id="install-nodejs"><a class="header" href="#install-nodejs">Install Node.js</a></h3>
<p>We recommend using the LTS version of Node.js 16. You can check your currently used Node.js version with the following command:</p>
<pre><code class="language-bash">node -v
#v16.18.0
</code></pre>
<p>If you do not have Node.js installed in your current environment, you can use <a href="https://github.com/nvm-sh/nvm">nvm</a> or <a href="https://github.com/Schniz/fnm">fnm</a> to install it.</p>
<p>Here is an example of how to install the Node.js 16 LTS version via nvm:</p>
<pre><code class="language-bash"># Install the LTS version of Node.js 16
nvm install 16 --lts

# Make the newly installed Node.js 16 as the default version
nvm alias default 16

# Switch to the newly installed Node.js 16
nvm use 16
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suggested-workflows"><a class="header" href="#suggested-workflows">Suggested Workflows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>We currently have two sets of test suites, one for Rust and one for Node.js.</p>
<h2 id="rust-testing"><a class="header" href="#rust-testing">Rust Testing</a></h2>
<ul>
<li><code>cargo test</code> will run all the rust side tests, which includes standalone tests for core functionality and plugins.</li>
<li><code>UPDATE=1 cargo test</code> will automatically update the failed snapshot</li>
</ul>
<h2 id="node-testing"><a class="header" href="#node-testing">Node Testing</a></h2>
<pre><code class="language-sh"># In root path
pnpm --filter &quot;./packages/**&quot; run build &amp;&amp; pnpm --filter &quot;./packages/**&quot; run test
</code></pre>
<p>Or only test the package that you made the changes:</p>
<pre><code class="language-sh"># In the Node.js package path
pnpm run build &amp;&amp; pnpm run test
</code></pre>
<p>To update snapshots:</p>
<pre><code class="language-sh">pnpm --filter '@rspack/*' test -- -u
</code></pre>
<h3 id="node-testing-suite-overview"><a class="header" href="#node-testing-suite-overview">Node Testing Suite Overview</a></h3>
<p>We use jest for Node.js tests, The most important test cases are the case in the <code>packages/rspack</code>. most of these cases comes from webpack https://github.com/webpack/webpack/tree/main/test because we want to make sure that Rspack can work as same as webpack.</p>
<p>There are three kinds of integration cases in <code>@rspack/core</code>.</p>
<h4 id="casetestts"><a class="header" href="#casetestts">case.test.ts</a></h4>
<p>Cases are used to test normal build behavior, we use these cases to test against bundler core functionality, like <code>entry</code>, <code>output</code>, <code>module</code> <code>resolve</code>, etc. it will first build your test file to test whether the input could be compiled successfully, then it will use the bundled test file to run test cases in the test file to test bundler's all kinds of behavior.</p>
<h4 id="configcasetestts"><a class="header" href="#configcasetestts">configCase.test.ts</a></h4>
<p>Cases are used to test custom build behavior, you could use custom <code>webpack.config.js</code> to override default build behavior, you can use these cases to test against behavior related to specific config.</p>
<h5 id="statstestcasetestts"><a class="header" href="#statstestcasetestts">statsTestCase.test.ts</a></h5>
<p>Cases are used to test your stats, By Default we will use jest's snapshot to snapshot your stats, and we <strong>highly</strong> recommend to <strong>avoid</strong> snapshot except statsCase. you can use statsCase to test behaviors like code splitting | bundle splitting, which is hard to test by just running code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e2e"><a class="header" href="#e2e">E2E</a></h1>
<p>The <code>packages/playground</code> provides e2e testing feature. We use <a href="https://github.com/Microsoft/playwright">playwright</a> as the e2e testing framework.</p>
<h2 id="cases"><a class="header" href="#cases">Cases</a></h2>
<p>The entry point of a test case is a file ending with <code>.test.ts</code>, and the parent directory of this file is the project directory.</p>
<p>Here are some rules about test cases:</p>
<ul>
<li>The project directory must contain <code>rspack.config.js</code> to start the dev server.</li>
<li>The project directory can contain multi <code>*.test.ts</code>.</li>
<li>All test cases share dependencies, so just add dependencies in <code>packages/playground/package.json</code>.</li>
<li>The cases folder should contain the category folders and then is the project folders. In principle, there should be no third-level directory.</li>
</ul>
<h2 id="fixtures"><a class="header" href="#fixtures">Fixtures</a></h2>
<p>The <code>fixtures</code> is a feature of playwright, in short it provides a variable that is generated in before{Each|All} and destroyed in after{Each|All}. More information see <a href="https://playwright.dev/docs/test-fixtures">test-fixtures</a></p>
<p>Here are some rules when defining a new fixture:</p>
<ul>
<li>Private fixtures should start with <code>_</code> and are used only in the current file.</li>
<li>A file only provides fixtures with the same name.</li>
<li>A file can only provide one option and starts with <code>default</code></li>
<li>Register fixtures in <code>fixtures/index.ts</code> and export only necessary variables and types.</li>
</ul>
<p>Here are some existing fixtures:</p>
<h4 id="pathinfo"><a class="header" href="#pathinfo">pathInfo</a></h4>
<p>This fixture will generate test environment, and calculate the PathInfo.</p>
<pre><code class="language-ts">type PathInfo = {
    // test file path
    testFile: string;
    // project dir
    testProjectDir: string
    // temporary project directory to be copied into
    tempProjectDir: string
}
</code></pre>
<h4 id="rspack"><a class="header" href="#rspack">rspack</a></h4>
<p>This fixture will start the rspack dev server and provide some useful methods.</p>
<pre><code class="language-ts">type Rspack = {
    // rspack running project directory
    projectDir: string
    // rspack compiler
    compiler: Compiler
    // rspack dev server
    devServer: DevServer
    // waiting for rspack build finish
    waitingForBuild: () =&gt; Promise&lt;void&gt;
    // waiting for hmr finish, the poll function is used to check
    waitingForHmr: (poll: () =&gt; Promise&lt;boolean&gt;) =&gt; Promise&lt;void&gt;
}
</code></pre>
<h4 id="fileaction"><a class="header" href="#fileaction">fileAction</a></h4>
<p>This fixture will provide file change operations.</p>
<pre><code class="language-ts">type fileAction = {
    updateFile(relativePath: string, fn: (content: string) =&gt; string): void
    deleteFile(relativePath: string): void
}
</code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<ul>
<li>playwright scan all test case and allocates a worker to run each case.</li>
<li><code>pathInfo</code> copy the project directory corresponding to the current case to <code>temp/${worker_index}</code>.</li>
<li><code>rspack</code> rewrite dev server port to <code>8000 + worker_index</code> and start compiler and dev server in <code>temp/${worker_index}</code>.</li>
<li>run current tests.</li>
<li><code>rspack</code> close dev server and compiler.</li>
<li><code>pathInfo</code> clear <code>temp/${worker_index}</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="debugging-with-vscode"><a class="header" href="#debugging-with-vscode">Debugging with VSCode</a></h2>
<ol>
<li>Install <code>go install github.com/go-delve/delve/cmd/dlv@latest</code></li>
<li>Install VSCode extension <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a> and <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a></li>
<li>build <code>@rspack/cli</code> and napi binding by run <code>pnpm install &amp;&amp; pnpm -w build:cli:debug</code></li>
<li>In VSCode's <code>Run and Debug</code> tab, select <code>debug-rspack</code> to start debugging the initial launch of <code>@rspack/cli</code>. This task can be configured in <code>.vscode/launch.json</code>, which launches the Node and Rust debugger together.</li>
</ol>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p><a href="https://crates.io/crates/tracing"><code>tracing</code></a> is used to instrumenting Rspack.</p>
<p>The supported tracing levels for</p>
<ul>
<li>release builds are <code>INFO</code>, <code>WARN</code> and <code>ERROR</code></li>
<li>debug builds are <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code> and <code>ERROR</code></li>
</ul>
<p>Use the <code>RSPACK_PROFILE</code> environment variable for displaying trace information</p>
<pre><code class="language-bash">RSPACK_PROFILE=TRACE=layer=logger rspack build
RSPACK_PROFILE='TRACE=layer=logger&amp;filter=rspack_core::compiler::compilation' rspack build # filter for an event
</code></pre>
<h2 id="rust-lldb"><a class="header" href="#rust-lldb">rust-lldb</a></h2>
<p><code>rust-lldb</code> can be used to get panic information from debug builds</p>
<pre><code class="language-bash">rust-lldb -- node /path/to/rspack build
</code></pre>
<p>Once it launches, press <code>r</code> for running the program.</p>
<p>For example, <code>examples/arco-pro</code> crashes without any information before <a href="https://github.com/web-infra-dev/rspack/pull/3195/files">this fix</a>:</p>
<pre><code>rspack/examples/arco-pro ❯ node ../../packages/rspack-cli/bin/rspack build
Rspack ██████████████████████░░░░░░░░░░░░░░░░░░ 56% building ./pages/welcome
zsh: bus error  node ../../packages/rspack-cli/bin/rspack build
</code></pre>
<p>Using <code>rust-lldb</code></p>
<pre><code class="language-bash">rspack/examples/arco-pro ❯ rust-lldb -- node ../../packages/rspack-cli/bin/rspack build
</code></pre>
<p>Press <code>r</code> and it prints:</p>
<pre><code>Process 23110 stopped
* thread #10, name = 'tokio-runtime-worker', stop reason = EXC_BAD_ACCESS (code=2, address=0x70000cc66560)
    frame #0: 0x0000000140d0db4b rspack.darwin-x64.node`swc_ecma_parser::parser::expr::ops::_$LT$impl$u20$swc_ecma_parser..parser..Parser$LT$I$GT$$GT$::parse_unary_expr::h29f49330a806839c(self=0x0000000000000000) at ops.rs:244
   241 	    /// Parse unary expression and update expression.
   242 	    ///
   243 	    /// spec: 'UnaryExpression'
-&gt; 244 	    pub(in crate::parser) fn parse_unary_expr(&amp;mut self) -&gt; PResult&lt;Box&lt;Expr&gt;&gt; {
   245 	        trace_cur!(self, parse_unary_expr);
   246 	        let start = cur_pos!(self);
   247
Target 0: (node) stopped.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p>In this section, we'll explore how to profile Rspack for identifying bottlenecks.
By examining where Rspack spends its time, we can gain insights into how to improve performance.</p>
<ul>
<li><a href="profiling/intro.html#tracing">Tracing</a>
<ul>
<li><a href="profiling/intro.html#chrome">Chrome</a></li>
<li><a href="profiling/intro.html#terminal">Terminal</a></li>
<li><a href="profiling/intro.html#nodejs-profiling">Nodejs Profiling</a></li>
</ul>
</li>
<li><a href="profiling/intro.html#mac-xcode-instruments">Mac Xcode Instruments</a></li>
</ul>
<h2 id="tracing-1"><a class="header" href="#tracing-1">Tracing</a></h2>
<p><a href="https://crates.io/crates/tracing"><code>tracing</code></a> is used to instrumenting Rspack.</p>
<p>The supported tracing levels for</p>
<ul>
<li>release builds are <code>INFO</code>, <code>WARN</code> and <code>ERROR</code></li>
<li>debug builds are <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code> and <code>ERROR</code></li>
</ul>
<p>Two ways to enable tracing:</p>
<ul>
<li>if you are using <code>@rspack/cli</code>, you can enable it by <code>RSPACK_PROFILE</code> environment variable.</li>
<li>if you are using <code>@rspack/core</code> without <code>@rspack/cli</code>, you can enable it by <code>experimental_registerGlobalTrace</code> and <code>experimental_cleanupGlobalTrace</code>, checkout <a href="https://github.com/web-infra-dev/rspack/blob/25df2981ce1f0232ab05109c0995a249f57e2a09/packages/rspack-cli/src/utils/profile.ts#L186-L187">how we implement <code>RSPACK_PROFILE</code> in <code>@rspack/cli</code> with these two function</a> for more details.</li>
</ul>
<h3 id="chrome"><a class="header" href="#chrome">Chrome</a></h3>
<p><a href="https://crates.io/crates/tracing-chrome"><code>tracing-chrome</code></a> is supported for viewing tracing information graphically.</p>
<p>Setting the environment variable <code>RSPACK_PROFILE=TRACE=layer=chrome</code> before running Rspack, for example</p>
<pre><code class="language-bash">RSPACK_PROFILE=TRACE=layer=chrome rspack build
</code></pre>
<p>produces a trace file (<code>.rspack-profile-${timestamp}/trace.json</code>) in the current working directory.</p>
<p>The JSON trace file can be viewed in either <code>chrome://tracing</code> or <a href="https://ui.perfetto.dev">ui.perfetto.dev</a>.</p>
<h3 id="terminal"><a class="header" href="#terminal">Terminal</a></h3>
<p>Granular tracing event values can be viewed inside the terminal via <code>RSPACK_PROFILE=TRACE=layer=logger</code>, for example</p>
<pre><code class="language-bash">RSPACK_PROFILE=TRACE=layer=logger rspack build
</code></pre>
<p>will print the options passed to Rspack as well as each individual tracing event.</p>
<h3 id="nodejs-profiling"><a class="header" href="#nodejs-profiling">Nodejs Profiling</a></h3>
<p>If we find that the performance bottleneck is on the JS side (e.g. js loader), then we need to further analyse the js side, and we can use Nodejs Profiling to analyse. for example</p>
<pre><code class="language-bash">node --cpu-prof {rspack_bin_path} -c rspack.config.js
</code></pre>
<p>or</p>
<pre><code class="language-bash">RSPACK_PROFILE=JSCPU rspack build
</code></pre>
<p>this will generates a cpu profile like <code>CPU.20230522.154658.14577.0.001.cpuprofile</code>, and we can use speedscope to visualize the profile, for example</p>
<pre><code class="language-bash">npm install -g speedscope
speedscope CPU.20230522.154658.14577.0.001.cpuprofile
</code></pre>
<h2 id="mac-xcode-instruments"><a class="header" href="#mac-xcode-instruments">Mac Xcode Instruments</a></h2>
<p>Xcode instruments can be used to produce a CPU profile if you are on a Mac.</p>
<p>To install Xcode Instruments, simply install the Command Line Tools:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>For normal Rust builds, <a href="https://github.com/cmyr/cargo-instruments"><code>cargo instruments</code></a> can be used as the glue
for profiling and creating the trace file.</p>
<p>Since Rspack takes quite a while to build, you can use the following procedure without invoking <code>cargo instruments</code>.
It has the same effect.</p>
<p>In <code>crates/node_binding/Cargo.toml</code>, turn on debug symbols and disable symbol stripping in the <code>[profile.release]</code> section</p>
<pre><code class="language-toml">[profile.release]
debug = 1 # debug info with line tables only
strip = false # do not strip symbols
</code></pre>
<p>Then build the project</p>
<pre><code class="language-bash">pnpm run build:cli:release
</code></pre>
<p>The final binary is located at <code>packages/rspack-cli/bin/rspack</code> once the project is built.</p>
<p>Under the hood, <code>cargo instruments</code> invokes the <code>xcrun</code> command,
which means we can run the following in our own project that uses Rspack.</p>
<pre><code class="language-bash">xcrun xctrace record --template 'Time Profile' --output . --launch -- /path/to/rspack/packages/rspack-cli/bin/rspack build
</code></pre>
<p>It produces the following output</p>
<pre><code>Starting recording with the Time Profiler template. Launching process: rspack.
Ctrl-C to stop the recording
Target app exited, ending recording...
Recording completed. Saving output file...
Output file saved as: Launch_rspack_2023-04-24_11.32.06_9CFE3A63.trace
</code></pre>
<p>We can open the trace file by</p>
<pre><code class="language-bash">open Launch_rspack_2023-04-24_11.32.06_9CFE3A63.trace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releasing"><a class="header" href="#releasing">Releasing</a></h1>
<p>All releases are automated through GitHub actions.</p>
<p>All published releases of <code>@rspack/cli</code> can be found on the <a href="https://www.npmjs.com/package/@rspack/cli?activeTab=versions">npm versions page</a>. They are tagged as</p>
<ul>
<li><code>latest</code> with semver version <code>x.y.z</code></li>
<li><code>nightly</code></li>
<li><code>canary</code></li>
</ul>
<h2 id="latest-full-release"><a class="header" href="#latest-full-release">Latest Full Release</a></h2>
<p>The <a href="https://github.com/web-infra-dev/rspack/actions/workflows/release.yml?query=is%3Asuccess">full release workflow</a>
is currently triggered manually every Tuesday with full release notes.</p>
<p>The following 9 targets are built</p>
<ul>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
<li>x86_64-unknown-linux-musl</li>
<li>aarch64-unknown-linux-musl</li>
<li>i686-pc-windows-msvc</li>
<li>x86_64-pc-windows-msvc</li>
<li>aarch64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
</ul>
<h2 id="nightly"><a class="header" href="#nightly">Nightly</a></h2>
<p>The <a href="https://github.com/web-infra-dev/rspack/actions/workflows/release-nightly.yml?query=is%3Asuccess">nightly release workflow</a>
is triggered every day at UTC 16:00:07, which is 00:07 AM Beijing Time (offset with an odd minute to avoid cron jobs firing off at the same time).</p>
<p>The nightly build fully replicates the full release build for catching errors early.</p>
<h2 id="canary"><a class="header" href="#canary">Canary</a></h2>
<p>Commenting on a PR with the text <code>!canary</code> triggers the <a href="https://github.com/web-infra-dev/rspack/actions/workflows/release-canary.yml?query=is%3Asuccess">canary release workflow</a>.
Only contributors have the permission to publish canary releases.</p>
<p>The canary release only builds three targets for quicker feedback</p>
<ul>
<li>aarch64-apple-darwin</li>
<li>x86_64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Thank you for your interest in contributing to Rspack! There are many ways to contribute, and we appreciate all of them.</p>
<h2 id="sending-a-pull-request"><a class="header" href="#sending-a-pull-request">Sending a Pull Request</a></h2>
<ol>
<li><a href="https://help.github.com/articles/fork-a-repo/">Fork</a> the Rspack repository into your own GitHub account.</li>
<li><a href="https://help.github.com/articles/cloning-a-repository/">Clone</a> the repository to your local.</li>
<li>Checkout a new branch from <code>main</code>.</li>
<li>Set up the development environment, you can read the &quot;Setup Development Environment&quot; section below to learn about it.</li>
<li>If you've fixed a bug or added code that should be tested, then add some tests.</li>
<li>Make sure all the tests pass, you can read the &quot;Testing&quot; section below to learn about it.</li>
<li>Run <code>pnpm run lint:js</code> and <code>pnpm run lint:rs</code> to check the code style.</li>
<li>If you've changed some Node.js packages, you should add a new <a href="https://github.com/changesets/changesets">changeset</a>. Run <code>pnpm run changeset</code>, select the changed packages and add the changeset info.</li>
<li>If you've changed some Rust packages, you should add a new <a href="https://github.com/changesets/changesets">changeset</a> for <code>@rspack/binding</code> package.</li>
<li>Submit the Pull Request, make sure all CI runs pass.</li>
<li>The maintainers will review your Pull Request soon.</li>
</ol>
<p>When submitting a Pull Request, please note the following:</p>
<ul>
<li>Keep your PRs small enough, so that each PR only addresses a single issue or adds a single feature.</li>
<li>Please include an appropriate description in the PR, and link related issues.</li>
</ul>
<h3 id="format-of-pr-titles"><a class="header" href="#format-of-pr-titles">Format of PR titles</a></h3>
<p>The format of PR titles follow Conventional Commits.</p>
<p>A example</p>
<pre><code>feat(ui): Add `Button` component
^    ^    ^
|    |    |__ Subject
|    |_______ Scope
|____________ Type
</code></pre>
<p>Your PR</p>
<ul>
<li>must have a <code>Type</code></li>
<li>Optionally have a <code>Scope</code>
<ul>
<li><code>Scope</code> should be lower case</li>
</ul>
</li>
<li>must have a <code>Subject</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-reproducible-example"><a class="header" href="#minimal-reproducible-example">Minimal reproducible example</a></h1>
<p>The <a href="https://github.com/web-infra-dev/rspack-repro">rspack repro template</a> can be used to create a minimal reproducible example.</p>
<p>A minimal reproducible example (MRE) is a code that is:</p>
<ul>
<li>Short</li>
<li>Self-contained</li>
<li>Demonstrates the problem being encountered</li>
</ul>
<p>An MRE is essential because it allows us to quickly understand and reproduce your issue.
This, in turn, increases the likelihood of getting a helpful and accurate response in a shorter amount of time.
It is important to note that an MRE should not include extraneous code related to unrelated functionality,
and should instead focus solely on the problem at hand.</p>
<p>Please see also <a href="https://stackoverflow.com/help/minimal-reproducible-example">How to create a Minimal, Reproducible Example</a> from Stackoverflow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-team"><a class="header" href="#about-the-team">About the team</a></h1>
<p>If you need guidance or assistance with a specific area of the project, check out the <a href="https://github.com/web-infra-dev/rspack/blob/main/.github/CODEOWNERS">CODEOWNERS</a> file on GitHub.
This file lists the preferred person to contact for each area.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-labels"><a class="header" href="#managing-labels">Managing labels</a></h1>
<p>This page explains the meanings of Rspack repository's labels.</p>
<ul>
<li><a href="contributing/managing-labels.html#c">C</a>
<ul>
<li><a href="contributing/managing-labels.html#contribution-welcome">Contribution welcome</a></li>
</ul>
</li>
<li><a href="contributing/managing-labels.html#g">G</a>
<ul>
<li><a href="contributing/managing-labels.html#good-first-issue">Good first issue</a></li>
</ul>
</li>
</ul>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<h3 id="contribution-welcome"><a class="header" href="#contribution-welcome">Contribution welcome</a></h3>
<h2 id="g"><a class="header" href="#g">G</a></h2>
<h3 id="good-first-issue-1"><a class="header" href="#good-first-issue-1">Good first issue</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rspack-1"><a class="header" href="#rspack-1">rspack</a></h1>
<p>This is the architecture of current rspack implementation</p>
<h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h1>
<p><a href="architecture/rspack/./loader.html">loader</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="related-prs"><a class="header" href="#related-prs">Related PRs</a></h1>
<ul>
<li><a href="https://github.com/web-infra-dev/rspack/pull/2789">rspack#2780</a></li>
<li><a href="https://github.com/web-infra-dev/rspack/pull/2808">rspack#2808</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>The old architecture is a quite simple version, which only supports loaders for normal stage.
Pitching loader does not put into consideration. The basic concept of the old version is to
convert the normal loader to a native function which can be called from the Rust side.
Furthermore, for performance reason, Rspack also composes loaders from the JS side to
mitigate the performance issue of Node/Rust communications.</p>
<p>In this new architecture, loaders will not be converted directly into native functions.
Instead, it is almost the same with how webpack's loader-runner resolves its loaders, by
leveraging the identifier. Every time Rspack wants to invoke a JS loader, the identifiers will
be passed to the handler passed by Node side to process. The implementation also keeps
the feature of composing JS loaders for performance reason.</p>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<p>The refactor does not introduce any other breaking changes. So it's backwards compatible.
The change of the architecture also help us to implement pitching loader with composability.</p>
<h2 id="pitching-loader"><a class="header" href="#pitching-loader">Pitching loader</a></h2>
<p>Pitching loader is a technique to change the loader pipeline flow. It is usually used with 
inline loader syntax for creating another loader pipeline. style-loader, etc and other loaders
which might consume the evaluated result of the following loaders may use this technique.
There are other technique to achieve the same ability, but it's out of this article's topic.</p>
<p>See <a href="https://webpack.js.org/api/loaders/#pitching-loader">Pitching loader</a> for more detail.</p>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<h2 id="actor-of-loader-execution"><a class="header" href="#actor-of-loader-execution">Actor of loader execution</a></h2>
<p>In the original implementation of loader, Rspack will convert the normal loaders in the first place,
then pass it to the Rust side. In the procedure of building modules, these loaders will be called directly:</p>
<p><img src="https://user-images.githubusercontent.com/10465670/233357319-e80f6b32-331c-416d-b4b5-30f3e0e394bd.png" alt="Old architecture" /></p>
<p>The loader runner is only on the Rust side and execute the loaders directly from the Rust side.
This mechanism has a strong limit for us to use webpack's loader-runner for composed loaders.</p>
<p>In the new architecture, we will delegate the loader request from the Rust core to a dispatcher 
located on the JS side. The dispatcher will normalize the loader and execute these using a modified
version of webpack's loader-runner:</p>
<p><img src="https://user-images.githubusercontent.com/10465670/233357805-923e0a27-609d-409a-b38d-96a083613235.png" alt="image" /></p>
<p>Loader functions for pitch or normal will not be passed to the Rust side. Instead, each JS loader has
its identifier to uniquely represent each one. If a module requests a loader for processing the module,
Rspack will pass identifier with options to the JS side to instruct the Webpack like loader-runner to
process the transform. This also reduces the complexity of writing our own loader composer.</p>
<h2 id="passing-options"><a class="header" href="#passing-options">Passing options</a></h2>
<p>Options will normally be converted to query, but some of the options contain fields that cannot be 
serialized, Rspack will reuse the <em><strong>loader ident</strong></em> created by webpack to uniquely identify the option
and restore it in later loading process.</p>
<h2 id="optimization-for-pitching"><a class="header" href="#optimization-for-pitching">Optimization for pitching</a></h2>
<p>As we had known before, each loader has two steps, pitch and normal. For a performance friendly
interoperability, we must reduce the communication between Rust and JS as minimum as possible.
Normally, the execution steps of loaders will look like this:</p>
<p><img src="https://user-images.githubusercontent.com/10465670/233360942-7517f22e-3861-47cb-be9e-6dd5f5e02a4a.png" alt="image" /></p>
<p>The execution order of the loaders above will looks like this:</p>
<pre><code>loader-A(pitch)
   loader-B(pitch)
      loader-C(pitch)
   loader-B(normal)
loader-A(normal)
</code></pre>
<p>The example above does not contain any JS loaders, but if, say, we mark these loaders registered on the
JS side:</p>
<p><img src="https://user-images.githubusercontent.com/10465670/233362338-93e922f6-8812-4ca9-9d80-cf294e4f2ff8.png" alt="image" /></p>
<p>The execution order will not change, but Rspack will compose the step 2/3/4 together for only a single
round communication.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webpack"><a class="header" href="#webpack">webpack</a></h1>
<p>This is the architecture of webpack implementation</p>
<h1 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h1>
<p><a href="architecture/webpack/./loader.html">loader</a>
<a href="architecture/webpack/./dependency.html">dependency</a></p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Based on <em>Webpack version: 5.73.0</em>.</p>
</blockquote>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Explain how webpack loader works. Even though it's a little bit long and tedious, It's still a teeny-tiny peek at the loader system of Webpack.</p>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<blockquote>
<p>What's the meaning of a word used to describe a feature?</p>
<p>Why does the Webpack introduce this and what's the background of introducing this? What kind of problem Webpack was facing at the time?</p>
</blockquote>
<h2 id="request-related"><a class="header" href="#request-related">Request Related</a></h2>
<pre><code class="language-javascript">import Styles from '!style-loader!css-loader?modules!./styles.css';
</code></pre>
<ul>
<li><a href="https://webpack.js.org/concepts/loaders/#inline">Inline loader syntax</a>: The syntax that chains the loader together within the specifier, followed by the file requested. e.g. <code>!style-loader!css-loader?modules!./style.css</code></li>
<li><code>request</code>: The request with <em>inline loader syntax</em> retained. Webpack will convert relative URLs and module requests to absolute URLs for loaders and files requested. e.g. <code>!full-path-to-the-loader-separated-with-exclamation-mark!full-path-to-styles.css</code></li>
</ul>
<h2 id="resource-related"><a class="header" href="#resource-related">Resource Related</a></h2>
<pre><code class="language-javascript">import xxx from &quot;./index.js?vue=true&amp;style#some-fragment&quot;
</code></pre>
<ul>
<li>
<p><a href="https://webpack.js.org/api/loaders/#thisresource"><code>resource</code></a>: The absolute path to the requested file with <code>query</code> and <code>fragment</code> retained but inline loader syntax removed. e.g. <code>absolute-path-to-index-js.js?vue=true&amp;style#some-fragment</code></p>
</li>
<li>
<p><a href="https://webpack.js.org/api/loaders/#thisresourcepath"><code>resourcePath</code></a>: The absolute path to the requested file only. e.g. <code>absolute-path-to-index-js.js</code></p>
</li>
<li>
<p><a href="https://webpack.js.org/api/loaders/#thisresourcequery"><code>resourceQuery</code></a>: Query with question mark <code>?</code>  included. e.g. <code>?vue=true&amp;style</code></p>
</li>
<li>
<p><a href="https://webpack.js.org/api/loaders/#thisresourcefragment"><code>resourceFragment</code></a>:  e.g. <code>#some-fragment</code></p>
</li>
<li>
<p>inline match resource: </p>
<ul>
<li>Used to redirect the <code>module.rules</code> to another, which is able to adjust the loader chain. We will cover this later.</li>
<li>Ref: <a href="https://github.com/webpack/webpack/pull/7462">related PR</a> <a href="https://webpack.js.org/api/loaders/#thisimportmodule">Webpack Doc1</a> <a href="https://webpack.js.org/api/loaders/#inline-matchresource">Webpack Doc2</a> </li>
</ul>
</li>
<li>
<p><code>virtualResource</code>:</p>
<ul>
<li>The proposed solution to support asset type changing(A sugar to inline matchResource, which can also affect the asset filename generation)</li>
<li>See more: <a href="https://github.com/webpack/webpack/issues/14851">the background of this property</a></li>
</ul>
</li>
</ul>
<h2 id="others-but-also-important-to-note"><a class="header" href="#others-but-also-important-to-note">Others but also important to note</a></h2>
<ul>
<li>Virtual Module: A kind of module that does not locate in the real file system. But you can still import it. To create a virtual module, you need to follow the <a href="https://www.ietf.org/rfc/rfc2397.txt">spec</a> and it's also worth noting that Node.js and Webpack both support it under the scheme of <code>data:</code>. Also known as, <code>data:</code> import. <a href="https://nodejs.org/api/esm.html#data-imports">Doc to Node.js</a></li>
<li><a href="https://webpack.js.org/concepts/modules/#supported-module-types">Module types</a> with native support: Webpack supports the following module types native: <code>'javascript/auto'</code> |<code> 'javascript/dynamic'</code> | <code>'javascript/esm'</code> | <code>'json'</code> | <code>'webassembly/sync'</code> | <code>'webassembly/async'</code> | <code>'asset'</code> | <code>'asset/source'</code> | <code>'asset/resource'</code> | <code>'asset/inline'</code>, for those types you can use it <strong>without a loader</strong>. From webpack version 4.0+, webpack can understand more than <code>javascript</code> alone.</li>
</ul>
<h1 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h1>
<h2 id="loader-configuration"><a class="header" href="#loader-configuration">Loader configuration</a></h2>
<p>The way that webpack controls what kind of module that each loader would apply is based on <code>module.rules</code></p>
<pre><code class="language-javascript">const MiniExtractCssPlugin = require(&quot;mini-extract-css-plugin&quot;)

module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: [&quot;vue-loader&quot;]
      },
      {
        test: /\.css$/,
        use: [MiniExtractCssPlugin.loader, &quot;css-loader&quot;]
      }
    ]
  },
  plugins: [new MiniExtractCssPlugin()]
}
</code></pre>
<p>Here is a simple option for the configuration of <code>vue-loader</code>. <code>module.rules[number].test</code> is a part rule to test <strong>whether a rule should be applied</strong>. For <code>vue-loader</code> alone, It's kind of confusing how webpack pass the result to the rule of <code>css</code>, we will cover this later. But for now, It's good to notice <strong>there is not only a <code>test</code> option alone to test if a rule should be applied</strong>. You can find it <a href="https://webpack.js.org/configuration/module/#rule">here</a> for full conditions supported. Here're some examples of other conditions you can use.</p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/, // of course, test if the file extension match `vue`.
        scheme: &quot;data&quot;, // if the specifier of a request starts with `data:`
        resourceQuery: &quot;?raw&quot;, // if the `resourceQuery` matches then the rule will be applied. For this example, it's a great idea to apply a `raw-loader` here.
        type: &quot;css&quot; // use webpack's native resource handling for css
      }
    ]
  }
}
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="vue1-to-n"><a class="header" href="#vue1-to-n">Vue(1 to n)</a></h3>
<p>In a single file component(SFC) of Vue, there are commonly three blocks or more blocks(<a href="https://vue-loader.vuejs.org/guide/custom-blocks.html#example">custom blocks</a>) contained. The basic idea of implementing this loader is to convert it into JavaScript / CSS and let webpack handle the chunk generation(e.g. Style should be generated into a separate <code>.css</code> file)</p>
<pre><code class="language-vue">&lt;template&gt;&lt;/template&gt;

&lt;style&gt;&lt;/style&gt;

&lt;script&gt;&lt;/script&gt;
</code></pre>
<p>⬇️⬇️⬇️⬇️⬇️⬇️</p>
<p><code>Vue-loader</code> will firstly turn into the <code>*.vue</code> file into something like that.</p>
<pre><code class="language-javascript">import &quot;script-path-to-vue-sfc&quot;;
import &quot;template-path-to-vue-sfc&quot;;
import &quot;style-path-to-vue-sfc&quot;;
</code></pre>
<p>You may find it weird how webpack handles these imports and build the transformed code. But if I change the code a little bit, you will find the idea.</p>
<pre><code class="language-javascript">import &quot;script:path-to-vue-sfc&quot;;
import &quot;template:path-to-vue-sfc&quot;;
import &quot;style:path-to-vue-sfc&quot;;
</code></pre>
<p>and if we tweak the configuration a little bit to this, webpack will know exactly how to work with these import statements.</p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: [&quot;vue-loader&quot;]
      },
      {
        scheme: &quot;script&quot;,
        use: [&quot;apply-your-javascript-loader&quot;, &quot;vue-script-extract-loader&quot;]
      },
      {
        scheme: &quot;template&quot;,
        use: [&quot;apply-your-javascript-loader&quot;, &quot;vue-template-extract-loader&quot;]
      },
      {
        scheme: &quot;style&quot;,
        use: [&quot;apply-your-style-loader&quot;, &quot;vue-style-extract-loader&quot;]
      }
    ]
  }
}
</code></pre>
<p>We added a few loaders to handle the splitting. I know it's still kind of weird here, but please stick with me and we will find a better way out.</p>
<ul>
<li>vue-script-extract-loader: extract the <code>script</code> block from a SFC file.</li>
<li>vue-style-extract-loader: extract the <code>style</code> block from a SFC file.</li>
<li>vue-template-extract-loader: extract the <code>template</code> block from a SFC file and convert it into JavaScript.</li>
</ul>
<p>You will find it's really noisy only to transform a <code>*.vue</code> file, four loaders were introduced and I believe none of you would like to separate a simple loader into four. It's a real bummer! It will be great to use a single loader <code>vue-loader</code> alone. The current vue loader implementation uses resourceQuery to handle this. But how?</p>
<h4 id="loader-optimizations-i"><a class="header" href="#loader-optimizations-i">Loader optimizations I</a></h4>
<p>We know that webpack uses a few conditions to handle whether a rule should be applied. Even with <code>rule.test</code> alone, the <code>this.reousrceQuery</code> is still available to <code>loaderContext</code> which developer could access it with <code>this</code> in any loader function(Don't worry if you still don't catch this. You will understand this after). Based on that, we change the <code>rule</code> to this: </p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /.vue$/,
        use: [&quot;vue-loader&quot;]
      }
    ]
  }
}
</code></pre>
<p>This indicates &quot;If an import specifier is encountered, please pass me to vue-loader&quot;! If you remember the import transformation above, we could adjust the transformation a little bit to this:</p>
<p><strong>Before</strong></p>
<pre><code class="language-javascript">import &quot;script-path-to-vue-sfc&quot;;
import &quot;template-path-to-vue-sfc&quot;;
import &quot;style-path-to-vue-sfc&quot;;
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-javascript">import &quot;path-to-vue-sfc.vue?script=true&quot;;
import &quot;path-to-vue-sfc.vue?template=true&quot;;
import &quot;path-to-vue-sfc.vue?style=true&quot;;
</code></pre>
<p>These requests will match the <code>test: /.vue$/</code> above flawlessly and in the loader we can handle like this:</p>
<pre><code class="language-javascript">// pseudo code only for proofing of the concept
const compiler = require(&quot;some-vue-template-compiler&quot;)

const loader = function(source) {
  const { 
    resourceQuery /* ?script=true or something else */, 
    resourcePath /* path-to-vue-sfc.vue */
  } = this
  
  if (resourceQuery === &quot;?script=true&quot;) {
    return compiler.giveMeCodeofScriptBlock(this.resourcePath) // javascript code
  } else if (resourceQuery === &quot;?template=true&quot;) {
    return compiler.giveMeCodeofTemplateBlock(this.resourcePath) // javascript code
  } else if (resourceQuery === &quot;?style=true&quot;) {
    return compiler.giveMeCodeofStyleBlock(this.resourcePath) // style code
  } else {
    return `
    	import `${this.resourcePath}?script=true`;
    	import `${this.resourcePath}?template=true`;
    	import `${this.resourcePath}?style=true`;
    `
  }
}

module.exports = loader
</code></pre>
<p>You can see the loader for the example above will be used for four times.</p>
<ol>
<li>Encounter a <code>*.vue</code> file, transform the code to a few import statements</li>
<li>For each import statement introduced in the first transformation, the loader will be used again as they share the same extension <code>vue</code>.</li>
</ol>
<p>Is this the end? No! Even if you wrote the code like this, it will still fail to load. </p>
<ol>
<li>For CSS: You haven't tell webpack a way to handle the CSS, remember the CSS part is required to go through the <code>css-loader</code> and then <code>mini-css-extract</code>(if you want to generate CSS for chunk) or <code>style-loader</code>(if you want to append it directly to the DOM). After all, you have to make the result of style to pass these loaders.</li>
<li>For JS: You haven't transformed the code to any transpilers, It will be failed if your runtime doesn't support the syntax(maybe in TypeScript for example) and webpack internal acorn compiler does not have the ability to help you with that.</li>
</ol>
<p><strong>Pass the code to the corresponding loaders</strong></p>
<p>We tweak the configuration a little bit again.</p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /.vue$/,
        use: [&quot;vue-loader&quot;]
      },
      {
        test: /.css$/,
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;]
      },
      {
        test: /.js$/,
        use: [&quot;babel-loader&quot;]
      }
    ]
  }
}
</code></pre>
<p>It looks a bit more like the &quot;normal&quot; Webpack configuration. Note that the <code>rule.test</code> is based on the file extension, so <code>vue-loader</code> did a little bit of hack here.</p>
<pre><code class="language-javascript">// pseudo code only for proofing of the concept
const compiler = require(&quot;some-vue-template-compiler&quot;)

const loader = function(source) {
  const { 
    resourceQuery /* ?script=true or something else */, 
    resourcePath /* path-to-vue-sfc.vue */
  } = this
  
  if (resourceQuery === &quot;?script=true&quot;) {
    const code = compiler.giveMeCodeofScriptBlock(this.resourcePath) // javascript code
    this.resourcePath += &quot;.js&quot;
    return code
  } else if (resourceQuery === &quot;?template=true&quot;) {
    const code = compiler.giveMeCodeofTemplateBlock(this.resourcePath) // javascript code
    this.resourcePath += &quot;.js&quot;
    return code
  } else if (resourceQuery === &quot;?style=true&quot;) {
    const code = compiler.giveMeCodeofStyleBlock(this.resourcePath) // style code
    this.resourcePath += &quot;.css&quot; // based on the `lang` in each script, the extension will be set accordingly.
    return code
  } else {
    return `
    	import `${this.resourcePath}?script=true`;
    	import `${this.resourcePath}?template=true`;
    	import `${this.resourcePath}?style=true`;
    `
  }
}

module.exports = loader
</code></pre>
<p>Webpack uses <code>resourcePath</code> to match a <code>module.rules</code>. So this hack will let webpack treat blocks accordingly as if they are real files with extensions of <code>js</code> | <code>css</code> |<code>...</code> .</p>
<p>Finally! But this is only a proof of concept, for the real implementation. You should definitely check out the <a href="https://github.com/vuejs/vue-loader"><code>vue-loader</code></a> yourself.</p>
<h4 id="loader-optimization-ii"><a class="header" href="#loader-optimization-ii">Loader Optimization II</a></h4>
<p>Well done! We implemented a simple and rudimentary version of <code>vue-loader</code>. However, the real pain-in-the-ass part of this implementation is hacking the extension to match the configuration. But since almost every user would have other <code>js</code> | <code>css</code> files included in the project, so vue team decide to use this kind of strategy to reuse the user configuration.</p>
<p>Except for hacking the extension, webpack then provided a more legit way to handle this kind of <strong>rule matching problem</strong> which is known as <em><strong>inline match resource</strong></em> (We covered it in the glossary part).</p>
<p><strong>inline match resource</strong></p>
<p>Webpack can do almost anything with an import specifier like the loader chaining we covered in the glossary part. <em>Inline source match</em> is another case. By taking the advantage of it, you can force an import statement to go through a <code>module.rules</code> by introducing the <code>!=!</code> syntax. For example, if we want to force a <code>css</code> file to go through a <code>less</code> loader, it will be look like this:</p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /.less$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;]
      }
    ]
  }
}
</code></pre>
<pre><code class="language-javascript">// This import should be converted with a loader

// treat the file as `less`
import &quot;./index.css.less!=!./index.css&quot;
</code></pre>
<p>The slice before the <code>!=!</code> is a way to modify the extension of a single file and force it to match the <code>module.rules</code> and this transformation is often done in a loader, or you will make your application code specialized for Webpack only.</p>
<p>After going through the basic example, let's see how we're going to optimize out the hack used in <code>vue-loader</code>.</p>
<pre><code class="language-javascript">// pseudo code only for proofing of the concept
const compiler = require(&quot;some-vue-template-compiler&quot;)

const loader = function(source) {
  const {
    resourceQuery /* ?script=true or something else */, 
    resourcePath /* path-to-vue-sfc.vue */
  } = this
  
  if (resourceQuery === &quot;?vue=true&amp;script=true&quot;) {
    return compiler.giveMeCodeofScriptBlock(this.resourcePath) // javascript code
  } else if (resourceQuery === &quot;?vue=true&amp;template=true&quot;) {
    return compiler.giveMeCodeofTemplateBlock(this.resourcePath) // javascript code
  } else if (resourceQuery === &quot;?vue=true&amp;style=true&quot;) {
    return compiler.giveMeCodeofStyleBlock(this.resourcePath) // style code
  } else {
    return `
    	import `${this.resourcePath}.js!=!${this.resourcePath}?vue=true&amp;script=true`;
    	import `${this.resourcePath}.js!=!${this.resourcePath}?vue=true&amp;template=true`;
    	import `${this.resourcePath}.css!=!${this.resourcePath}?vue=true&amp;style=true`;
    `
  }
}

module.exports = loader
</code></pre>
<p>Webpack will internally use the match resource part(before <code>!=!</code>) as the data to match loaders. In order to let <code>vue-loader</code> match the resource. We have two options: </p>
<ol>
<li>Loose test</li>
<li><em>Inline loader syntax</em></li>
</ol>
<p><strong>1. Loose test</strong></p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.vue/, // original: `/\.vue$/`, we removed the `$` to allow resources with `.vue` included to match this rule.
        use: [&quot;vue-loader&quot;]
      }
    ]
  }
}
</code></pre>
<p>We removed the <code>$</code> to allow resources with <code>.vue</code> included matching this rule. Personally speaking, this is not a good idea, because a loose match might cause mismatches.</p>
<p><strong>2. Inline loader syntax</strong></p>
<pre><code class="language-javascript">// vue-loader/index.js

module.exports = function() {
 // ... code omitted
	return `
  	import `${this.resourcePath}.js!=!${__filename}!${this.resourcePath}?vue=true&amp;script=true`;
  	import `${this.resourcePath}.js!=!${__filename}!${this.resourcePath}?vue=true&amp;template=true`;
  	import `${this.resourcePath}.css!=!${__filename}!${this.resourcePath}?vue=true&amp;style=true`;
	`
}  
</code></pre>
<p>This technique is to take advantage of the <em><strong>inline loader syntax</strong></em> to force the loader to go through the vue loader. This tackles down the tangible mismatching ideally and we can still retain the test regex <code>/\.vue$/</code> as-is.</p>
<h4 id="final-art-and-conclusion"><a class="header" href="#final-art-and-conclusion">Final art and conclusion</a></h4>
<p><strong>Configuration</strong></p>
<pre><code class="language-javascript">module.exports = {
	module: {
    rules: [
      {
        test: /\.vue$/,
        use: [&quot;vue-loader&quot;]
      },
      // ... other rules for js, or css, etc.
    ]
  }  
}
</code></pre>
<p><strong>Loader</strong></p>
<pre><code class="language-javascript">// pseudo code only for proofing of the concept
const compiler = require(&quot;some-vue-template-compiler&quot;)

const loader = function(source) {
  const {
    resourceQuery /* ?script=true or something else */, 
    resourcePath /* path-to-vue-sfc.vue */
  } = this
  
  if (resourceQuery === &quot;?vue=true&amp;script=true&quot;) {
    return compiler.giveMeCodeofScriptBlock(resourcePath) // javascript code
  } else if (resourceQuery === &quot;?vue=true&amp;template=true&quot;) {
    return compiler.giveMeCodeofTemplateBlock(resourcePath) // javascript code
  } else if (resourceQuery === &quot;?vue=true&amp;style=true&quot;) {
    return compiler.giveMeCodeofStyleBlock(resourcePath) // style code
  } else {
    return `
    	import `${this.resourcePath}.js!=!${__filename}!${resourcePath}?vue=true&amp;script=true`;
    	import `${this.resourcePath}.js!=!${__filename}!${resourcePath}?vue=true&amp;template=true`;
    	import `${this.resourcePath}.css!=!${__filename}!${resourcePath}?vue=true&amp;style=true`;
    `
  }
}

module.exports = loader
</code></pre>
<p><strong>Conclusion</strong></p>
<p>Vue-loader is quite complex. The basic needs of the loader are:</p>
<ol>
<li>Separate a <code>*.vue</code> file request into a number of parts. For each block, explicitly change the resource matching mechanism (using  <em><strong>inline match resource</strong></em>). The killer <em>inline match resource</em> not only gives us great composability with user-defined loaders, but also the ability to interact with webpack supported native types, and we will cover this part late.</li>
<li>When requesting the <code>vue-loader</code> again for a block, the code of each block is returned and let webpack handle the changed matched resource(e.g. <code>./App.vue.css</code>) with user-defined loaders (Webpack did this internally).</li>
</ol>
<h3 id="use-natively-supported-module-types"><a class="header" href="#use-natively-supported-module-types">Use natively supported module types</a></h3>
<p>We know that webpack only supports <code>JavaScript</code> in the old time, from the version of <code>4.0.0</code>+(<a href="https://github.com/webpack/webpack/releases/tag/v4.0.0">changelog</a>)</p>
<h4 id="simplified-pre-processors-configuration"><a class="header" href="#simplified-pre-processors-configuration">Simplified pre-processor's configuration</a></h4>
<blockquote>
<p>With the experimental support of CSS. A.K.A webpack knows how to handle CSS files natively.</p>
</blockquote>
<p><strong>Before</strong></p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],
        type: &quot;javascript/auto&quot; // this field is a implicit one, if not defined, it will be set to `&quot;javascript/auto&quot;`
      }
    ]
  }
}
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [&quot;less-loader&quot;],
        type: &quot;css&quot;
      }
    ]
  },
  experiments: {
    css: true
  }
}
</code></pre>
<p>With <code>experiments.css</code> on, webpack can experimentally understand the parsing and generating of <code>css</code> files which gets rid of <code>css-loader</code> and <code>style-loader</code>. For the full list of natively supported <code>Rule.type</code>, you can find it <a href="https://webpack.js.org/configuration/module/#ruletype">here</a>.</p>
<h4 id="asset-modules"><a class="header" href="#asset-modules">Asset modules</a></h4>
<blockquote>
<p>From <em>webpack 4.0.0+</em>, assets are supported natively</p>
</blockquote>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg)/,
        type: &quot;asset&quot;
      }
    ]
  }
}
</code></pre>
<p><code>Rule.type === &quot;asset&quot;</code>  indicates the asset will be automatically tested whether it's going to be inlined or emitted as a file on the real file system. The possible options are: <code>'asset'</code> | <code>'asset/source'</code> | <code>'asset/resource'</code> | <code>'asset/inline'</code></p>
<h3 id="svgr"><a class="header" href="#svgr">Svgr</a></h3>
<p>Webpack loader will read the source to a UTF-8 string by default. For SVG files, this would fit the webpack load defaults.</p>
<pre><code class="language-javascript">// Proof of concept of svgr-loader
module.exports = function(source) {
  if (this.resourceQuery === &quot;?svgr=true&quot;) { // the real transform part
    let { code } = svgrTransformer.transform(source);
    return code
  }
  return `require(&quot;${this.resourcePath}.jsx!=!${__filename}!${this.resourcePath}?svgr=true&quot;)` // the request part
}
</code></pre>
<p>Again here we use double-pass to firstly convert each request to the request part with <em>inline match resource</em>, and do the real request with query <code>?svgr=true</code>, and let <em>inline match resource</em> handle the <code>jsx</code> conversion. Before that, we have to call a third-party <code>jsx</code> transformer, could be <em>ESBuild</em> for example, for which we cannot reuse other <code>module.rules</code> set by the user-side. <em>Inline match resource</em> saved our ass again!</p>
<h3 id="scheme-imports"><a class="header" href="#scheme-imports">Scheme imports</a></h3>
<blockquote>
<p>Supported in <em>Webpack version 5.38.0</em>, doc: <a href="https://webpack.js.org/configuration/module/#rulescheme">Rule.scheme</a></p>
</blockquote>
<pre><code class="language-javascript">// JavaScript
import x from &quot;data:text/javascript,export default 42&quot;
console.log('x:',x);
</code></pre>
<pre><code class="language-css">/* CSS */
@import (&quot;data:text/css, body { background: #fff; }&quot;);
</code></pre>
<p>Webpack handles <code>data:</code> imports for JavaScript internally.</p>
<h3 id="asset-transform-and-rename"><a class="header" href="#asset-transform-and-rename">Asset transform and rename</a></h3>
<blockquote>
<p><a href="https://webpack.js.org/guides/asset-management/"><strong>Asset</strong></a>: This is a general term for the images, fonts, media, and any other kind of files that are typically used in websites and other applications. These typically end up as individual files within the <a href="https://webpack.js.org/glossary/#o">output</a> but can also be inlined via things like the <a href="https://webpack.js.org/loaders/style-loader">style-loader</a> or <a href="https://webpack.js.org/loaders/url-loader">url-loader</a>.</p>
<p><em>Originally posted at Webpack <a href="https://webpack.js.org/glossary/#a">Glossary</a></em></p>
</blockquote>
<h4 id="default-resource-reading-override"><a class="header" href="#default-resource-reading-override">Default resource reading override</a></h4>
<p>Asset could be formatted in both text(<code>*.svg</code>) or binary (<code>*.png</code> / <code>*.jpg</code>). For loaders, webpack provides you an option <a href="https://webpack.js.org/api/loaders/#raw-loader"><code>raw</code></a> to override the default and built-in resource reading strategy from UTF-8  <code>string</code> to <code>Buffer</code>: </p>
<pre><code class="language-javascript">module.exports = function(source /* Buffer */ ) {
  // loader implementation
}

module.exports.raw = true
</code></pre>
<h4 id="transform-and-rename"><a class="header" href="#transform-and-rename">Transform and rename</a></h4>
<p>Image there is a need to transform an asset formatted with <code>png</code> to <code>jpg</code>. There is two abilities that webpack needs to support:</p>
<ol>
<li>Handle the asset with <code>raw</code> content, or a <code>Buffer</code>. We can simply override the default resource reading behavior by exporting <code>raw</code>(covered before).</li>
<li>Change the filename, and reuse the loader for both <code>png</code> and  <code>jpg</code></li>
</ol>
<h5 id="configuration"><a class="header" href="#configuration">Configuration</a></h5>
<pre><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.png/,
        use: [&quot;png-to-jpg-loader&quot;] // some png to jpg loader, we will implement this
      },
      {
        test: /\.jpg/,
        use: [&quot;jpg-optimizer&quot;] // some jpg optimizer, we will not covert this,
        type: &quot;asset/resource&quot;
      }
    ]
  }
}
</code></pre>
<ol>
<li>Rule1: For files with extension <code>png</code>, we want to use a <code>png</code> to <code>jpg</code> loader, which will be covered in this article.</li>
<li>Rule2: 
<ol>
<li>For files with extension <code>jpg</code>, we want to use a third-party  <code>jpg-optimizer</code>, which will not be covered in this article.</li>
<li><code>type: &quot;asset/resource&quot;</code>: As soon as all the loaders have gone through, we want webpack to emit the file as an external resource on the file system regardless of the file size(<code>type: &quot;asset&quot;</code> will automatically detect the size of an asset to determine whether an asset will be inline-included for dynamically imported from file system).</li>
</ol>
</li>
<li>For those <code>jpg</code> files converted from <code>png</code>, we want them to apply with the <code>jpg-optimizer</code> too(i.e. reuse the loaders defined in <code>module.rules</code>)</li>
</ol>
<h5 id="loader"><a class="header" href="#loader">Loader</a></h5>
<pre><code class="language-javascript">module.exports = function(source) {
  if (this.resourceQuery === &quot;?pngToJPG=true&quot;) {
    return pngToJpg.transform(source)
  }
  
  return `require(&quot;${this.resourcePath}.jpg!=!${__filename}${this.resourcePath}?pngToJPG=true&quot;)`
}

module.exports.raw = true
</code></pre>
<p>We use double-pass again, firstly we convert the extension to <code>.jpg</code> which will apply the matched rules(in this case <code>test: /\.jpg/</code>), after the transformation of <code>png-to-jpg-loader</code>. Generated asset module filename will be based on the <em>inline match resource</em>, which is <code>xxxx.jpg</code> in this case.</p>
<h3 id="ast-reuse"><a class="header" href="#ast-reuse">AST reuse</a></h3>
<p>Webpack provides a way to pass metadata(the forth parameter) among the chaining loaders <a href="https://webpack.js.org/api/loaders/#thiscallback">doc</a>. The most commonly used value is <code>webpackAST</code> which accepts an <code>ESTree</code> compatible(webpack internally uses <code>acorn</code>) AST, which hugely improves the performance since webpack instead of parsing the returned code to AST again, <strong>will directly use the AST(<code>webpackAST</code>) returned from a loader</strong>(But <strong>the work of a complete walking of an AST can not be omitted</strong> as it's necessary for webpack for do some analysis for its dependencies and will be only done once, so it is not a big overhead.)</p>
<pre><code class="language-javascript">module.exports = function(source) {
  let ast = AcornParser.parse(source, {
    // options
  })
  
  this.callback(null, '', null, {
    webpackAST: ast
  })
}
</code></pre>
<p>Good to note that only <code>ESTree</code> is compatible, so you cannot pass a CSS AST, or webpack will complain with <code>&quot;webpackAst is unexpected for the CssParser&quot;</code>. It will be ok if you don't get this, let's move to the reference-level explanation for analysis in-depth.</p>
<h2 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h2>
<p>This is the reference-level explanation part of webpack's internal loader implementation.</p>
<h3 id="loader-composability"><a class="header" href="#loader-composability">Loader composability</a></h3>
<blockquote>
<p>If you don't quite get this concept, you may refer to the Glossary and <em>Example</em> part of the Guide-level explanation first and pick up this as soon as you finished.</p>
</blockquote>
<p>The high-level idea of previously talked <em>inline match resource</em> is to let <strong>loader developers</strong> to customize the behavior of matching to match the pre-defined <code>module.rules</code>. It's an API to write composable loaders. But what does composition mean? For those users who are familiar with React hooks and Vue composable APIs, you may get this faster. Actually, webpack provides a lot of ways to help loader developers and users do the composition.</p>
<h4 id="user-defined-loader-flows"><a class="header" href="#user-defined-loader-flows">User-defined loader flows</a></h4>
<pre><code class="language-javascript">module.exports = {
  module: {
 	  rules: [
      {
        test: /\.js$/,
        use: [&quot;babel-loader&quot;],
        type: &quot;javascript/auto&quot;
      },
      {
        test: /\.svg$/,
        use: [&quot;svgr-loader&quot;, &quot;svgo-loader&quot;],
      }
    ] 
  }
}
</code></pre>
<p>Webpack users can take the advantage of  <code>module.rules[number].use</code> with a loader list for each request that matches the corresponding conditions. Note that I use the wording of <code>request,</code> not the <code>file</code> , which can include a request to <code>data:text/javascript</code> not the files on the real file system only. (In Parcel bundler, it's called <a href="https://parceljs.org/features/plugins/#pipelines"><em>pipelines</em></a>, but this will not be covered in this article.)</p>
<p>Apparently, user-declared loader flow is not able to cover up every case that a loader wants. You can see from the previous examples, <code>vue-loader</code> wants to split a file into many blocks, and remain the reference to it.  <code>svgr-loader</code> wants to do the transformation first and let other loaders deal with the <code>jsx</code>. <code>svg-loader</code> wants to use the internal ability of <code>Asset Module</code> to let Webpack decide whether an asset is inlined or emitted to the real file system. and there are more to come... Based on the complexity of the loader, Webpack also provides a syntax to allow loader implementors to do the composition by themselves.</p>
<h4 id="the-syntax-for-loader-composition"><a class="header" href="#the-syntax-for-loader-composition">The syntax for loader composition</a></h4>
<h5 id="inline-loader-syntax-chaining-loaders"><a class="header" href="#inline-loader-syntax-chaining-loaders">Inline loader syntax (Chaining loaders)</a></h5>
<blockquote>
<p>Supported from <em>webpack v1</em> <a href="https://webpack.js.org/migrate/3/#chaining-loaders">chaining-loaders</a></p>
<p>It's possible to specify loaders in an <code>import</code> statement, or any <a href="https://webpack.js.org/api/module-methods">equivalent &quot;importing&quot; method</a>. Separate loaders from the resource with <code>!</code>. Each part is resolved relative to the current directory. <a href="https://webpack.js.org/concepts/loaders/#inline">doc</a></p>
</blockquote>
<pre><code class="language-javascript">import Styles from '!style-loader!css-loader?modules!./styles.css';
</code></pre>
<p>The <em>inline loader syntax</em> executes each loader for each request from right to left. Webpack handles the interaction with user-defined loaders carefully. So by default, the user-defined normal loader will be executed prior to the inline loaders, you can disable this behavior by prefixing <code>!</code> , (full reference could be found here <a href="https://webpack.js.org/concepts/loaders/#inline">doc</a>). </p>
<p>The custom specifier is parsed before the <code>module.rules</code> as the <em>inline loader syntax</em> interferes the user-defined loaders(See the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModuleFactory.js#L390-L403">source code</a>). Then, webpack will get the <code>module.rules</code> combined with the required conditions to calculate the matching rule set (See the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModuleFactory.js#L493-L510">source code</a>).</p>
<p>At the moment, you cannot change the matching behavior with the syntax, loaders are always matched with the provided <em>resourcePath</em>, etc, which leads to a bunch of hack code in the implementations of loaders (see this <a href="https://github.com/vuejs/vue-loader/blob/e9314347d75a1b0e54f971272d23a669fc3e6965/src/select.ts#L31">code snippet</a> in <code>vue-loader</code>). The possibilities for changing the matching behavior leaves to the later-coming <em>inline match resource</em>. </p>
<p>Nevertheless, the architecture of Loader at this moment is sound and solid. Another good example is the implementation-nonrelative filter(i.e. the filtering logic of <em>Loader</em> is not declared in the loader itself), which is the fundamental root of loader composition, or the implementor will do a lot of hacks. (It's way too dirty to talk about here, but you can take the rollup <a href="https://github.com/gregberge/svgr/blob/1dbc3e2c2027253b3b81b92fd4eb09a4aa8ae25e/packages/rollup/src/index.ts#L52">svgr</a> plugin as a reference)</p>
<p>In conclusion, <em>inline loader syntax</em> gives us a chance to control the loader flow with user-defined rules.</p>
<h5 id="inline-match-resource"><a class="header" href="#inline-match-resource">Inline match resource</a></h5>
<p>To extend the matching ability, <em>inline match resource</em> enables loader implementors to reuse some of the user-defined configurations with more flexibilities. </p>
<p>On top of the previous example, webpack also provides a way to make use of the natively-supported <em>module types</em>.</p>
<pre><code class="language-javascript">// For module type `css` to work, you need to enable `experiments.css`
import &quot;./style.less.webpack[css]!=path-to-less-loader!./style.less&quot;
</code></pre>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  experiments: {
    css: true
  }
}
</code></pre>
<p>Given the configuration above, the overview of the complete flow will be like this:</p>
<ol>
<li>Webpack: Parse the specifier of the import and create the loader for the current request</li>
<li>Webpack: Merge the result from the second step with a user-defined <code>module.rules</code> in <code>webpack.config</code>, in this case is <code>[]</code></li>
<li>Webpack: load <code>style.less</code> as UTF-8 string</li>
<li>Less-loader: Accept the UTF-8 string as the first parameter of the loader function and transform it to the content of <code>css</code>.</li>
<li>Webpack: Call the registered native <code>CSS</code> parser, and later at the code generation step the registered native <code>CSS</code> generator generates the result.</li>
</ol>
<p>For <em>asset modules</em>, you can also use this:</p>
<pre><code class="language-javascript">import &quot;./logo.png.jpg.webpack[asset/resource]!=path-to-loaders!./logo.png&quot;
</code></pre>
<p>The first part, also known as <code>matchResource</code> will be used as a part of the <code>filename</code> of the final code generation. (See the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/asset/AssetGenerator.js#L293-L348">source code</a>)</p>
<h3 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance optimizations</a></h3>
<p>Before moving on to the detailed implementations, here's some glossary to support your understanding the architecture as a whole.</p>
<h4 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h4>
<ul>
<li><code>NormalModuleFactory</code>: A factory used to create a <code>NormalModule</code>, which basically exposes a <code>create</code> method.</li>
<li><code>NormalModule</code>: A module in Webpack most of the time is a <code>NormalModule</code>, but with different implementations of <code>parser</code>/ <code>generator</code> / <code>Module Type</code>, the module could be almost any kind, and also exposes a <code>build</code> method. For example, a <code>NormalModule</code> with JavaScript parser, JavaScript generator, and <code>type ===javascript/auto</code> will be regarded as a module with JavaScript-related functionalities. Also, good to note that a module may not exist on the real file system, taking <code>data:</code> for example.</li>
</ul>
<h4 id="the-module-creation-workflow"><a class="header" href="#the-module-creation-workflow">The module creation workflow</a></h4>
<blockquote>
<p>This will only introduce a slice of webpack's internal implementation from <strong>the Loader's perspective</strong>, for more you should directly refer to the source code.</p>
</blockquote>
<p>When an import statement is detected, webpack will initialize a module creation. Based on the type of <em>Dependency</em> (an abstraction of webpack, it's not important here), webpack can find the linked <em>ModuleFactory</em>(The abstraction class), in most cases, the derived factory is <code>NormalModuleFactory</code>, which exposes a <code>create</code> method.</p>
<h5 id="prepare-data-needed-for-module-creation"><a class="header" href="#prepare-data-needed-for-module-creation">Prepare data needed for module creation</a></h5>
<p>The <code>NormalModuleFactory#create</code> is used to provide enough information to create a real <code>NormalModule</code>, and create the <code>NormalModule</code>. In the <code>create</code> method, webpack basically does these things(some non-loader related stuff will be omitted):</p>
<ul>
<li>Resolve loaders from request: resolve the request, parse inline loader syntax: This contains <em>inline match resource</em>, <em>inline loader syntax</em>.</li>
<li>Do the analysis on the parsed loader syntax, to decide whether a user-defined <code>normal/post/pre</code> loader is going to be included. <a href="https://webpack.js.org/concepts/loaders/#inline">doc</a></li>
<li>Resolve Resource: resolve resource to the absolute path, fragments, queries, etc(These stuff are also provided in <code>LoaderContext</code>). For the full source code you may refer to <a href="https://github.com/webpack/webpack/blob/main/lib/NormalModuleFactory.js#L653-L678">this</a></li>
<li>Use the resolved resource data to match <code>module.rules</code> defined in the configuration, and get the matched rules. This is also a part of the module creation data.</li>
<li>Do some special logic with <em>inline match resource</em>, since match resource ends like <code>.webpack[css]</code> would change  <code>Rule.type</code>. Also store the match resource data, since it might affect the filename generation for  <em>asset modules</em>.</li>
</ul>
<h5 id="create-a-module-based-on-the-prepared-data"><a class="header" href="#create-a-module-based-on-the-prepared-data">Create a module based on the prepared data</a></h5>
<p>After the data needed for module creation is prepared, <code>NormalModuleFactory</code>  will <code>new NormalModule</code> with the data provided. It contains basically every that a <code>NormalModule</code> needs (see the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModule.js#L271-L287">source code</a>). Most importantly, the <code>loaders</code>. It contains every loader parsed and ordered from the <code>create</code> step.</p>
<h4 id="the-module-build-step"><a class="header" href="#the-module-build-step">The module build step</a></h4>
<p>The module build step is kind of clear. Webpack will invoke the <code>build</code> method for each <code>NormalModule</code> instance, which invokes <code>loader-runner</code>(see the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModule.js#L819">source code</a>) to go through every loader that was analyzed from the create step. It's clear to <strong>know that the composition of loaders is happening on the same module</strong>.</p>
<h4 id="a-peek-of-the-support-of-module-types"><a class="header" href="#a-peek-of-the-support-of-module-types">A peek of the support of <em>Module Types</em></a></h4>
<p>As far as this article goes, It might be getting a little bit tedious. But have you ever wondered how webpack supports these <em>module types</em> natively? I think It's still worth telling you about it to get a more complete understanding of the AST optimizations. For the support of JavaScript, webpack's JavaScript plugin will register different types of parser and generators for each <em>module types</em>, which will be used as the <code>parser</code> / <code>generator</code> to a <code>NormalModule</code> (see the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/javascript/JavascriptModulesPlugin.js#L202-L231">source code</a>).</p>
<h4 id="reusing-ast-in-webpack"><a class="header" href="#reusing-ast-in-webpack">Reusing AST in Webpack</a></h4>
<p>Based on the parser and generator we introduced before, webpack did a little hack around the fourth parameter of <code>this.callback</code> (from <em>loaderContext</em>), with <code>webpackAST</code>, after each loader call, the <code>webpackAST</code> will be stored in the context of loader, and passed again to the next loader. Finally, the AST will be passed to the <code>parser</code>(It could be any type, based on the <em>module type</em>, but webpack makes it a JavaScript only for AST) (see the <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModule.js#L1087">source code</a>).</p>
<p>Here's an issue about trying to use SWC's AST to get rid of the time sensitive code parsing from Acorn Parser, but they are facing some AST compatibility issues and performance issues about the overhead of interop with native code(Rust).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>
<p>loader plugin api design (Analysis) <a href="https://github.com/speedy-js/rspack/discussions/315">#315</a></p>
</li>
<li>
<p>RFC-011 Supports <code>data:text/javascript</code> protocol <a href="https://github.com/speedy-js/rspack/discussions/457">#457</a></p>
</li>
<li>
<p>Webpack: <code>matchResource</code> with natively-supported module types <a href="https://webpack.js.org/api/loaders/#thisimportmodule">doc</a></p>
</li>
<li>
<p>Webpack: Loader context <a href="https://webpack.js.org/api/loaders/#the-loader-context">doc</a></p>
</li>
<li>
<p>Webpack: Module rules <a href="https://webpack.js.org/configuration/module/#rule">doc</a></p>
</li>
<li>
<p>SWC-loader for performance optimizations <a href="https://github.com/webpack/webpack/issues/13425#issuecomment-1013560170">issue</a> </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Based on <em>Webpack version: 5.73.0</em>.
Some source code is omitted for cleaner demonstration in the example.</p>
</blockquote>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>Explain how webpack dependency affects the compilation and what kind of problem that webpack was facing at the moment and the solution to the problem.</p>
<h1 id="glossary-2"><a class="header" href="#glossary-2">Glossary</a></h1>
<blockquote>
<p>What's the meaning of a word used to describe a feature?</p>
<p>Why does the Webpack introduce this and what's the background of introducing this? What kind of problem Webpack was facing at the time?</p>
</blockquote>
<h2 id="high-level-presentations-of-dependencies"><a class="header" href="#high-level-presentations-of-dependencies">High-level presentations of <em>Dependencies</em></a></h2>
<ul>
<li><a href="https://webpack.js.org/api/loaders/#thisadddependency">Dependency(fileDependency)</a>: An existing dependency that is marked as watchable. This is the widely-used type of dependency. CSS Preprocessors like <code>postcss</code> strongly depend on this in order to mark its dependency watchable.</li>
<li><a href="https://webpack.js.org/api/loaders/#thisaddcontextdependency">ContextDependency</a>: Most useful for requests in which Glob and Regexp were used. For real-world usage, see [<a href="https://webpack.js.org/guides/dependency-management/#require-with-expression">this</a>](https://webpack.js.org/guides/dependency-management/#require-with-expression).</li>
<li><a href="https://webpack.js.org/api/loaders/#thisaddmissingdependency">MissingDependency</a>: A missing dependency to mark it watchable (handles the creation of files during compilation before watchers are attached correctly.)</li>
<li><a href="https://webpack.js.org/configuration/cache/#cachebuilddependencies">BuildDependency</a>: Related to persistent cache.</li>
<li>PresentationalDependency: Dependencies that only affect presentation are mostly used with their associated template.</li>
</ul>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<ul>
<li><a href="https://webpack.js.org/api/loaders/#the-loader-context">LoaderContext</a>: Context provided by Webpack <em>loader-runner</em>, which can be accessed through <code>this</code> in each loader function.</li>
<li>ModuleGraph: A graph to describe the relationship between modules.</li>
</ul>
<h1 id="guide-level-explanation-2"><a class="header" href="#guide-level-explanation-2">Guide-level explanation</a></h1>
<h2 id="dependency"><a class="header" href="#dependency"><code>Dependency</code></a></h2>
<p><code>dependency</code>(<code>fileDependency</code>) stands for the file <em>dependency</em> among <code>missingDependency</code> and <code>contextDependency</code>, etc. The created dependency will be marked as watchable, which is useful in <em>Hot Module Replacement</em> in developer mode.</p>
<p>The implicit behavior for webpack internally in the case below is to create two dependencies internally.</p>
<pre><code class="language-js">import foo from &quot;./foo&quot;;
import &quot;./style.css&quot;;
</code></pre>
<h2 id="contextdependency"><a class="header" href="#contextdependency"><code>ContextDependency</code></a></h2>
<p><code>contextDependency</code> is mostly used in scenarios where we want to dynamic load some module in runtime. In this case, webpack cannot assure which module it will be included in the final bundle at compile time. In order to make the code runnable in runtime, webpack has to firstly create multiple bundle modules corresponding to the matching filename such as <code>./components/a.js</code> and <code>./components/b.js</code>, etc.</p>
<pre><code class="language-js">// index.js
import(&quot;./components&quot; + componentName).then(...)
</code></pre>
<pre><code class="language-js">// components/a.js
...
export default ComponentA;
</code></pre>
<pre><code class="language-js">// components/b.js
...
export default ComponentB;
</code></pre>
<p>For loaders, you can access to <code>this.addContextDependency</code> in each loader function.
For plugins, you can access via <code>module.buildInfo.contextDependencies</code>.</p>
<h1 id="reference-level-explanation-2"><a class="header" href="#reference-level-explanation-2">Reference-level explanation</a></h1>
<blockquote>
<p>The abstraction of <em>Dependency</em> of Webpack was introduced in Webpack version 0.9 with a big refactor. <a href="https://github.com/webpack/webpack/commit/ee01837d66a44f1dd52fd1e174a6669e0d18dd55">Redirect to the commit</a></p>
</blockquote>
<h2 id="stakeholders-of-dependency"><a class="header" href="#stakeholders-of-dependency">Stakeholders of <em>Dependency</em></a></h2>
<h3 id="high-level"><a class="header" href="#high-level">High-level</a></h3>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663578968.png" alt="image-20220919171608629" /></p>
<h3 id="low-level"><a class="header" href="#low-level">Low-level</a></h3>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663579121.png" alt="image-20220919171841624" /></p>
<h2 id="how-dependencies-affect-the-creation-of-module-graph"><a class="header" href="#how-dependencies-affect-the-creation-of-module-graph">How <em>dependencies</em> affect the creation of <em>module graph</em>?</a></h2>
<h3 id="duplicated-module-detection"><a class="header" href="#duplicated-module-detection">Duplicated module detection</a></h3>
<p>Each module will have its own <code>identifier</code>, for <code>NormalModule</code>, you can find this in <code>NormalModule#identifier</code>. If the identifier will be duplicated if inserted in <code>this._module</code>, then webpack will directly skip the remaining build process. <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L1270-L1274">[source]</a></p>
<p>Basically, an <code>NormalModule</code> identifier contains these parts:</p>
<ol>
<li><code>type</code> [<code>string</code>]: The module type of a module. If the type of the module is <code>javascript/auto</code>, this field can be omitted</li>
<li><code>request</code> [<code>string</code>]: Request to the module. All loaders whether it's inline or matched by a config will be stringified. If <em>inline match resource</em> exists, inline loaders will be executed before any normal-loaders after pre-loaders. A module with a different loader passed through will be treated as a different module regardless of its path. </li>
<li><code>layer</code>: applied if provided</li>
</ol>
<h3 id="module-resolution"><a class="header" href="#module-resolution">Module resolution</a></h3>
<p><code>getResolve</code> is a loader API on the <code>LoaderContext</code>. Loader developers can pass <code>dependencyType</code> to its <code>option</code> which indicates the category of the module dependency that will be created. Values like <code>esm</code> can be passed, then webpack will use type <code>esm</code> to resolve the dependency. </p>
<p>The resolved dependencies are automatically added to the current module. This is driven by the internal plugin system of <code>enhanced-resolve</code>. Internally, <code>enhanced-resolve</code> uses plugins to handle the dependency registration like <code>FileExistsPlugin</code> <a href="https://github.com/webpack/enhanced-resolve/blob/e5ff68aef5ab43b8197e864181eda3912957c526/lib/FileExistsPlugin.js#L34-L54">[source]</a> to detect whether a file is located on the file system or will add this file to a list of <code>missingDependency</code> and report in respect of the running mode of webpack. The collecting end of Webpack is generated by the <code>getResolveContext</code> in <code>NormalModule</code> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/NormalModule.js#L513-L524">[source]</a></p>
<h3 id="module-dependency-in-modulegraph"><a class="header" href="#module-dependency-in-modulegraph"><em>Module dependency</em> in <em>ModuleGraph</em></a></h3>
<p>Here's a module graph with <code>esm</code> import between modules:</p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663579279.png" alt="image-20220919172119861" /></p>
<p>The dependency type introduced by <code>import</code> or <code>require</code> is a derived dependency: <em>ModuleDependency</em>.</p>
<p>A <em>ModuleDependency</em> contains three important fields.</p>
<ol>
<li><code>category</code>: used to describe the category of dependency. e.g. &quot;esm&quot; | &quot;commonjs&quot;</li>
<li><code>request</code>: see the explanation above.</li>
<li><code>userRequest</code>: Resource and its inline loader syntax will be stringified and applied, but loaders in <code>module.rules</code> will be omitted.</li>
</ol>
<p>It's also good to note a field we will talk about later:</p>
<ol>
<li><code>assertions</code>: assertions in <code>import xx from &quot;foo.json&quot; assert { type: &quot;json&quot; }</code></li>
</ol>
<p>More fields can be found in abstract class of <em>Dependency</em> and <em>ModuleDependency</em>. <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Dependency.js#L88">source: Dependency</a> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/ModuleDependency.js#L17">source: ModuleDependency</a></p>
<pre><code class="language-js">// null -&gt; index.js

EntryDependency {
  category: &quot;esm&quot;,
  request: &quot;./index.js&quot;,
  type: &quot;entry&quot;,
  _parentModule: undefined
}
</code></pre>
<pre><code class="language-js">// index.js -&gt; foo.js

HarmonyImportSideEffectDependency {
  category: &quot;esm&quot;,
  request: &quot;./foo&quot;,
  type: &quot;harmony side effect evaluation&quot;,
  _parentModule: NormalModule { identifier: &quot;index.js&quot; }
}
</code></pre>
<pre><code class="language-js">// index.js -&gt; bar.js

HarmonyImportSideEffectDependency {
  category: &quot;esm&quot;,
  request: &quot;./bar&quot;,
  type: &quot;harmony side effect evaluation&quot;,
  _parentModule: NormalModule { identifier: &quot;index.js&quot; }
}
</code></pre>
<pre><code class="language-js">// bar.js -&gt; foo.js
HarmonyImportSideEffectDependency {
  category: &quot;esm&quot;,
  request: &quot;./foo&quot;,
  type: &quot;harmony side effect evaluation&quot;,
  _parentModule: NormalModule { identifier: &quot;bar.js&quot; }
}
</code></pre>
<h3 id="resolving-a-module"><a class="header" href="#resolving-a-module">Resolving a module</a></h3>
<p><em>ModuleDependencies</em> with different dependency category such as <code>esm</code> or <code>commonjs</code> will affect the resolving part. For ECMAScript modules, they may prefer <code>&quot;module&quot;</code> to <code>&quot;main&quot;</code>, and for <em>CommonJS</em> modules, they may use <code>&quot;main&quot;</code> in <code>package.json</code>. On top of that, conditional exports are also necessary to be taken into account. <a href="https://nodejs.org/api/packages.html#conditional-exports">doc</a></p>
<h3 id="different-types-of-module-dependencies"><a class="header" href="#different-types-of-module-dependencies">Different types of <em>module dependencies</em></a></h3>
<h4 id="esm-related-derived-types"><a class="header" href="#esm-related-derived-types">ESM-related derived types</a></h4>
<p>There are a few of <em>ModuleDependencies</em> introduced in ESM imports. A full list of each derived type can be reached at <a href="https://github.com/webpack/webpack/blob/86a8bd9618c4677e94612ff7cbdf69affeba1268/lib/dependencies/HarmonyImportDependencyParserPlugin.js">[source]</a></p>
<h5 id="import"><a class="header" href="#import">Import</a></h5>
<p><strong><code>HarmonyImportDependency</code></strong></p>
<p>The basic type of harmony-related <em>module dependencies</em> are below. <a href="https://github.com/webpack/webpack/blob/86a8bd9618c4677e94612ff7cbdf69affeba1268/lib/dependencies/HarmonyImportDependency.js#L51">[source]</a></p>
<p><strong><code>HarmonyImportSideEffectDependency</code></strong></p>
<pre><code class="language-js">import { foo, bar } from &quot;./module&quot;
import * as module from &quot;./module&quot;
import foo from &quot;./module&quot;
import &quot;./module&quot;
</code></pre>
<p>Every import statement will come with a <code>HarmonyImportSideEffectDependency</code>, no matter how the specifiers look like. The speicifier will be handled by <code>HarmonyImportSpecifierDendency</code> below.</p>
<p>The field <code>assertions</code> will be stored if any import assertions exist for later consumption.
The field <code>category</code> will be used as <code>dependencyType</code> to resolve modules.</p>
<p><strong><code>HarmonyImportSpecifierDependency</code></strong></p>
<pre><code class="language-js">import { foo, bar } from &quot;./module&quot;
import * as module from &quot;./module&quot;
import foo from &quot;./module&quot;
</code></pre>
<p>Example:</p>
<pre><code class="language-js">import { foo, bar } from &quot;./module&quot;

console.log(foo, bar)
</code></pre>
<p>Specifier will be mapped into a specifier dependency if and only if it is used. JavaScript parser will first tag each variable <a href="https://github.com/webpack/webpack/blob/86a8bd9618c4677e94612ff7cbdf69affeba1268/lib/dependencies/HarmonyImportDependencyParserPlugin.js#L137">[source]</a>, and then create corresponding dependencies on each reading of dependency. <a href="https://github.com/webpack/webpack/blob/86a8bd9618c4677e94612ff7cbdf69affeba1268/lib/dependencies/HarmonyImportDependencyParserPlugin.js#L189">[source]</a> and finally be replaced to the generated <code>importVar</code>.</p>
<h5 id="exportthey-are-not-module-dependencies-to-be-actual-but-i-placed-here-for-convenience"><a class="header" href="#exportthey-are-not-module-dependencies-to-be-actual-but-i-placed-here-for-convenience">Export(They are not module dependencies to be actual, but I placed here for convenience)</a></h5>
<p><strong><code>HarmonyExportHeaderDependency</code></strong></p>
<blockquote>
<p>PresentationalDependency</p>
</blockquote>
<pre><code class="language-js">export const foo = &quot;foo&quot;;
export default &quot;foo&quot;;
</code></pre>
<p>This is a <em>presentational dependency</em>. We will take more time on this later.</p>
<p><strong><code>HarmonyExportSpecifierDependency</code></strong></p>
<pre><code class="language-js">export const foo = &quot;foo&quot;; // `foo` is a specifier

HarmonyExportSpecifierDependency {
  id: string;
  name: string;
}
</code></pre>
<p><strong><code>HarmonyExportExpressionDependency</code></strong></p>
<pre><code class="language-js">export default &quot;foo&quot;; // &quot;foo&quot; is an expression

HarmonyExportExpressionDependency {
 range: [number, number] // range of the expression
 rangeStatement: [number, number] // range of the whole statement
}
</code></pre>
<h2 id="how-dependencies-affect-code-generation"><a class="header" href="#how-dependencies-affect-code-generation">How <em>dependencies</em> affect code generation</a></h2>
<h3 id="presentational-dependency"><a class="header" href="#presentational-dependency"><em>Presentational dependency</em></a></h3>
<blockquote>
<p>A type of dependency that only affects code presentation.</p>
</blockquote>
<p><strong><code>ConstDependency</code></strong></p>
<pre><code>ConstDependency {
  expression: string
  range: [number, number]
  runtimeRequirements: Set&lt;string&gt; | null
}
</code></pre>
<p>You can think of the passed <code>expression</code> as a <code>replacement</code> for the corresponding <code>range</code>. For the real world example, you can directly refer to <em>Constant Folding</em>.</p>
<h3 id="template"><a class="header" href="#template"><em>Template</em></a></h3>
<p>Remember the fact that Webpack is an architecture wrapped around source code modifications. <em>Template</em> is the solution that helps Webpack to do the real patch on the source code. Each dependency has its associated <em>template</em> which affects a part of the code generation scoped per dependency. In other words, the effect of each <em>template</em> is strictly scoped to its associated dependency. </p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663579980.png" alt="image-20220919173300220" /></p>
<p>There are three types of modification: </p>
<ul>
<li><code>source</code></li>
<li><code>fragments</code></li>
<li><code>runtimeRequirements</code></li>
</ul>
<p>A boilerplate of the dependency template looks like this: </p>
<pre><code class="language-js">class SomeDependency {}

SomeDependency.Template = class SomeDependencyTemplate {
   /**
	 * @param {Dependency} dependency the dependency for which the template should be applied
	 * @param {ReplaceSource} source the current replace source which can be modified
	 * @param {DependencyTemplateContext} templateContext the context object
	 * @returns {void}
	 */
   apply(dependency, source, templateContext) {
      // do code mod here
   }
}
</code></pre>
<p>There are three parameters in the function signature: </p>
<ul>
<li>dependency: The associated dependency of this template</li>
<li>source: The source code represent in <code>ReplaceSource</code>, which can be used to replace a snippet of code with a new one, given the start and end position</li>
<li>templateContext: A context of template, which stores the corresponding <code>module</code>, <code>InitFragments</code>, <code>moduleGraph</code>, <code>runtimeRequirements</code>, etc. (not important in this section)</li>
</ul>
<h4 id="source"><a class="header" href="#source"><code>Source</code></a></h4>
<p>Again, given an example of <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/ConstDependency.js#L20"><code>ConstDependency</code></a>, even if you don't have an idea what it is, it doesn't matter. We will cover this in the later sections.</p>
<p>The associated template modifies the code with <code>Source</code>(<code>ReplaceSource</code> to be more specific):</p>
<pre><code class="language-js">ConstDependency.Template = class ConstDependencyTemplate extends (
	NullDependency.Template
) {
	apply(dependency, source, templateContext) {
		const dep = /** @type {ConstDependency} */ (dependency);
        
        // not necessary code is removed for clearer demonstration 

        if (dep.runtimeRequirements) {
			for (const req of dep.runtimeRequirements) {
				templateContext.runtimeRequirements.add(req);
			}
		}

		source.replace(dep.range[0], dep.range[1] - 1, dep.expression);
	}
};
</code></pre>
<h4 id="runtimerequirements"><a class="header" href="#runtimerequirements"><code>runtimeRequirements</code></a></h4>
<p>As you can see from the <code>Source</code> section above, there is another modification we talked about: <code>runtimeRequirements</code>, It adds
runtime requirements for the current <code>compilation</code>. We will explain more in the later sections.</p>
<h4 id="fragments"><a class="header" href="#fragments"><code>Fragments</code></a></h4>
<p>Essentially, a <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/InitFragment.js"><em>fragment</em></a> is a pair of code snippet that to be wrapped around each <em>module</em> source. Note the wording &quot;wrap&quot;, it could contain two parts <code>content</code> and <code>endContent</code> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/InitFragment.js#L69">[source]</a>. To make it more illustrative, see this:</p>
<img width="390" alt="image" src="https://user-images.githubusercontent.com/10465670/190576169-43ac19c4-2783-46c3-9059-b64b1ff72c4e.png">
<p>The order of the fragment comes from two parts:</p>
<ol>
<li>The stage of a fragment: if the stage of two fragments is different, then it will be replaced corresponding to the order define by the stage</li>
<li>If two fragments share the same order, then it will be replaced in <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/InitFragment.js#L41">position</a> order.
<a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/InitFragment.js#L153-L159">[source]</a></li>
</ol>
<p><strong>A real-world example</strong></p>
<pre><code class="language-js">import { foo } from &quot;./foo&quot;

foo()
</code></pre>
<p>Given the example above, here's the code to generate a dependency that replaces <code>import</code> statement with <code>__webpack_require__</code>.</p>
<pre><code class="language-js">// some code is omitted for cleaner demonstration
parser.hooks.import.tap(
        &quot;HarmonyImportDependencyParserPlugin&quot;,
              (statement, source) =&gt; {
	              const clearDep = new ConstDependency(
		              &quot;&quot;,
		              statement.range
	              );
	              clearDep.loc = statement.loc;
	              parser.state.module.addPresentationalDependency(clearDep);

	              const sideEffectDep = new HarmonyImportSideEffectDependency(
		              source
	              );
	              sideEffectDep.loc = statement.loc;
	              parser.state.module.addDependency(sideEffectDep);

	              return true;
              }
);
</code></pre>
<p>Webpack will create two dependencies <code>ConstDependency</code> and <code>HarmonyImportSideEffectDependency</code> while parsing <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/HarmonyImportDependencyParserPlugin.js#L110-L132">[source]</a>.</p>
<p>Let me focus on <code>HarmonyImportSideEffectDependency</code> more, since it uses <code>Fragment</code> to do some patch. </p>
<pre><code class="language-js">// some code is omitted for cleaner demonstration
HarmonyImportSideEffectDependency.Template = class HarmonyImportSideEffectDependencyTemplate extends (
	HarmonyImportDependency.Template
) {
	apply(dependency, source, templateContext) {
		super.apply(dependency, source, templateContext);
	}
};
</code></pre>
<p>As you can see in its associated <em>template</em> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/HarmonyImportSideEffectDependency.js#L59">[source]</a>, the modification to the code is made via its superclass <code>HarmonyImportDependency.Template</code> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/HarmonyImportDependency.js#L244">[source]</a>.</p>
<pre><code class="language-js">// some code is omitted for cleaner demonstration
HarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (
	ModuleDependency.Template
) {
	apply(dependency, source, templateContext) {
		const dep = /** @type {HarmonyImportDependency} */ (dependency);
		const { module, chunkGraph, moduleGraph, runtime } = templateContext;

		const referencedModule = connection &amp;&amp; connection.module;

		const moduleKey = referencedModule
			? referencedModule.identifier()
			: dep.request;
		const key = `harmony import ${moduleKey}`;
                
                 // 1
		const importStatement = dep.getImportStatement(false, templateContext);
                 // 2
		templateContext.initFragments.push(
			new ConditionalInitFragment(
				importStatement[0] + importStatement[1],
				InitFragment.STAGE_HARMONY_IMPORTS,
				dep.sourceOrder,
				key,
				// omitted for cleaner code
			)
		);
	}
}
</code></pre>
<p>As you can see from the simplified source code above, the actual patch made to the generated code is via <code>templateContext.initFragments</code>(2). The import statement generated from dependency looks like this.</p>
<pre><code class="language-js">/* harmony import */  var _foo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foo */ &quot;./src/foo.js&quot;); //(1)
</code></pre>
<p>Note, the real require statement is generated via <em>initFragments</em>, <code>ConditionalInitFragment</code> to be specific. Don't be afraid of the naming, for more information you can see the (background)[https://github.com/webpack/webpack/pull/11802] of this <em>fragment</em>, which let's webpack to change it from <code>InitFragment</code> to <code>ConditionalInitFragment</code>.</p>
<p><strong>How does webpack solve the compatibility issue?</strong></p>
<p>For ESM modules, webpack will additionally call a helper to define <code>_esModule</code> on exports as an hint:</p>
<pre><code class="language-js">__webpack_require__.r(__webpack_exports__);
</code></pre>
<p>The call of a helper is always placed ahead of any <code>require</code> statements. Probably you have already get this as the stage of <code>STAGE_HARMONY_EXPORTS</code> has high priority than <code>STAGE_HARMONY_IMPORTS</code>. Again, this is achieved via <code>initFragments</code>. The logic of the compatibility helper is defined in <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/HarmonyCompatibilityDependency.js">this</a> file, you can check it out.</p>
<h3 id="runtime"><a class="header" href="#runtime">Runtime</a></h3>
<p>Runtime generation is based on the previously collected <code>runtimeRequirements</code> in different dependency templates and is done after the code generation of each module. Note: it's not after the <code>renderManifest</code>, but it's after the code generation of each module. </p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663580309.png" alt="image-20220919173829765" />In the first iteration of collection, Sets of <code>runtimeRequirements</code> are collected from the module's code generation results and added to each <code>ChunkGraphModule</code>.</p>
<p>In the second iteration of collection, the collected <code>runtimeRequirements</code> are already stored in <code>ChunkGraphModule</code>, so Webpack again collects them from there and stores the runtimes required by each chunk of <code>ChunkGraphChunk</code>. It's kind of the hoisting procedure of the required runtimes.</p>
<p>Finally, also known as the third iteration of collection, Webpack hoists <code>runtimeRequirements</code> from those chunks that are referenced by the entry chunk and get it hoisted on the <code>ChunkGraphChunk</code> using a different field named <code>runtimeRequirementsInTree</code> which indicates not only does it contains the runtime requirements by the chunk but also it's children runtime requirements.</p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663580492.png" alt="image-20220919174132772" /></p>
<p>The referenced source code you can be found it <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L3379">here</a> and these steps are basically done in <code>processRuntimeRequirements</code>. This let me recall the linking procedure of a rollup-like bundler. Anyway, after this procedure, we can finally generate <em>runtime modules</em>. Actually, I lied here, huge thanks to the hook system of Webpack, the creation of <em>runtime modules</em> is done in this method via calls to <code>runtimeRequirementInTree</code><a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/Compilation.js#L3498">[source]</a>. No doubt, this is all done in the <code>seal</code> step. After that, webpack will process each chunk and create a few code generation jobs, and finally, emit assets.</p>
<h3 id="hot-module-replacement"><a class="header" href="#hot-module-replacement"><em>Hot module replacement</em></a></h3>
<p>Changes made via <em>hot module replacement</em> is mostly come from <code>HotModuleReplacementPlugin</code>.</p>
<p>Given the code below:</p>
<pre><code class="language-js">if (module.hot) {
  module.hot.accept(...)
}
</code></pre>
<p>Webpack will replace expressions like <code>module.hot</code> and <code>module.hot.accept</code>, etc with <code>ConstDependency</code> as the <em>presentationalDependency</em> as I previously talked about. <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/HotModuleReplacementPlugin.js#L97-L101">[source]</a></p>
<p>With the help of a simple expression replacement is not enough, the plugin also introduce additional runtime modules for each entries. <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/HotModuleReplacementPlugin.js#L736-L748">[source]</a></p>
<p>The plugin is quite complicated, and you should definitely checkout what it actually does, but for things related to dependency, it's enough.</p>
<h2 id="how-dependencies-affect-production-optimizations"><a class="header" href="#how-dependencies-affect-production-optimizations">How <em>dependencies</em> affect production optimizations</a></h2>
<h3 id="constant-folding"><a class="header" href="#constant-folding">Constant folding</a></h3>
<blockquote>
<p>The logic is defined in ConstPlugin : <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/ConstPlugin.js#L135">[source]</a></p>
</blockquote>
<p><em>Constant folding</em> is a technique that used as an optimization for optimization. For example:</p>
<p><strong>Source</strong></p>
<pre><code class="language-js">if (process.env.NODE_ENV === &quot;development&quot;) {
   ...
} else {
   ...
}
</code></pre>
<p><strong>Generated</strong></p>
<pre><code class="language-js">if (true) {
  ...
}
</code></pre>
<p>With mode set to <code>&quot;development&quot;</code>, webpack will &quot;fold&quot; the expression <code>process.env.NODE_ENV === &quot;development&quot;</code> into an expression of <code>&quot;true&quot;</code> as you can see for the code generation result. </p>
<p>In the <code>make</code> procedure of webpack, Webpack internally uses an <code>JavaScriptParser</code> for JavaScript parsing. If an <code>ifStatement</code> is encountered, Webpack creates a corresponding <code>ConstDependency</code>. Essentially, for the <code>ifStatement</code>, the <code>ConstDependency</code> looks like this :</p>
<pre><code class="language-js">ConstDependency {
  expression: &quot;true&quot;,
  range: [start, end] // range to replace
}
</code></pre>
<p>It's almost the same with <code>else</code> branch, if there is no <em>side effects</em>(refer to source code for more detail), Webpack will create another <code>ConstDependency</code> with <code>expression</code> set to <code>&quot;&quot;</code>, which in the end removes the <code>else</code> branch.</p>
<p>In the <code>seal</code> procedure of Webpack, the record of the dependency will be applied to the original source code and generate the final result as you may have already seen above.</p>
<h3 id="tree-shaking--dce"><a class="header" href="#tree-shaking--dce">Tree shaking &amp; DCE</a></h3>
<p>Tree-shaking is a technique of a bundle-wise DCE(dead code elimination). In the following content, I will use tree-shaking as a wording for bundle-wise and DCE for module-wise code elimination. (I know it's not quite appropriate, but you get the point)</p>
<p>Here's an example:</p>
<pre><code class="language-js">// webpack configuration
module.exports = {
  optimization: {
    usedExports: true
  }
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663583216.png" alt="image-20220919182656468" /></p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663585553.png" alt="image-20220919190553215" /></p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663585765.png" alt="image-20220919190925073" /></p>
<p>As you can see from the red square, the <code>initFragment</code> is generated based on the usage of the exported symbol in the <code>HarmonyExportSpecifierDependency</code> <a href="https://github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/dependencies/HarmonyExportSpecifierDependency.js#L91-L107">[source]</a></p>
<p>If <code>foo</code> is used in the graph, then the generated result will be this:</p>
<pre><code class="language-js">/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   &quot;foo&quot;: function() { return /* binding */ foo; }
/* harmony export */ });
const foo = &quot;foo&quot;;
</code></pre>
<p>In the example above, the <code>foo</code> is not used, so it will be excluded in the code generation of the template of <code>HarmonyExportSpecifierDependency</code> and it will be dead-code-eliminated in later steps. For terser plugin, it eliminates all unreachable code in <code>processAssets</code> <a href="https://github.com/webpack-contrib/terser-webpack-plugin/blob/580f59c5d223a31c4a9c658a6f9bb1e59b3defa6/src/index.js#L836">[source]</a>.</p>
<h2 id="things-related-to-persistent-cache"><a class="header" href="#things-related-to-persistent-cache">Things related to Persistent cache</a></h2>
<p><em>TODO</em></p>
<h2 id="wrap-it-up"><a class="header" href="#wrap-it-up">Wrap it up!</a></h2>
<p>Let's wrap everything up in a simple example! Isn't it exciting?</p>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663597948.png" alt="image-20220919223228146" /></p>
<p>Given a module graph that contains three modules, the entry point of this bundle is <code>index.js</code>. To not make this example too complicated, we use normal import statements to reference each module (i.e: only one chunk that bundles everything will be created).</p>
<h3 id="make"><a class="header" href="#make"><code>Make</code></a></h3>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663598158.png" alt="image-20220919223558327" /></p>
<h3 id="dependencies-after-make"><a class="header" href="#dependencies-after-make">Dependencies after <code>make</code></a></h3>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220919_1663598240.png" alt="image-20220919223720739" /></p>
<h3 id="seal"><a class="header" href="#seal"><code>seal</code></a></h3>
<p><img src="https://raw.githubusercontent.com/h-a-n-a/static/main/2022/09/upgit_20220920_1663668558.png" alt="image-20220920180915326" /></p>
<h1 id="references-1"><a class="header" href="#references-1">References</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meetings"><a class="header" href="#meetings">Meetings</a></h1>
<h2 id="tuesday-meeting"><a class="header" href="#tuesday-meeting">Tuesday meeting</a></h2>
<ol>
<li>Go through the <a href="https://github.com/web-infra-dev/rspack/milestones">iteration plan</a></li>
</ol>
<h2 id="thursday-meeting"><a class="header" href="#thursday-meeting">Thursday meeting</a></h2>
<ol>
<li>Go through any topics that need <a href="https://github.com/web-infra-dev/rspack/issues?q=is%3Aopen+label%3A%22to+be+discussed%22+sort%3Aupdated-desc">to be discussed</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releases"><a class="header" href="#releases">Releases</a></h1>
<ul>
<li>
<p><code>0.1.0</code> -&gt; <code>0.1.1</code> is a patch release.</p>
</li>
<li>
<p><code>0.1.0</code> -&gt; <code>0.2.0</code> is a minor release.</p>
</li>
<li>
<p><code>0.1.0</code> -&gt; <code>1.0.0</code> is a major release.</p>
</li>
</ul>
<p>See details at <a href="https://semver.org/">semver.org</a></p>
<h2 id="release-cycle"><a class="header" href="#release-cycle">Release Cycle</a></h2>
<ul>
<li>
<p>Patch releases are released Tuesday per week. </p>
</li>
<li>
<p>Minor releases are released as needed. </p>
</li>
<li>
<p>Major releases are released as needed. </p>
</li>
</ul>
<p>See <a href="https://github.com/web-infra-dev/rspack/milestones?direction=asc&amp;sort=title&amp;state=open">milestones</a> to follow our release plan.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misc"><a class="header" href="#misc">Misc</a></h1>
<h2 id="need-documentation-label"><a class="header" href="#need-documentation-label">&quot;need documentation&quot; label</a></h2>
<p>This is used for reminding ourselves to update the Rspack website for a new feature.</p>
<p>When a PR is merged with the &quot;need documentation&quot; label,
<a href="https://github.com/rspack-bot">rspack-bot</a> will create a corresponding PR
in the <a href="https://github.com/web-infra-dev/rspack-website">rspack-website</a> repo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-learning-resources"><a class="header" href="#appendix-a-learning-resources">Appendix A: Learning resources</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<h2 id="webpack-1"><a class="header" href="#webpack-1">Webpack</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-z-fun-stuff"><a class="header" href="#appendix-z-fun-stuff">Appendix Z: Fun stuff</a></h1>
<h2 id="motto"><a class="header" href="#motto">Motto</a></h2>
<p><strong>Question webpack, understand webpack, become webpack</strong></p>
<h2 id="team-building-game"><a class="header" href="#team-building-game">Team building game</a></h2>
<p>Despite being located across different cities, the rspack team has found an enjoyable way to bond when we meet in person.
We play a team building game where we ask each other webpack questions.
@hardfist hasn't lost a single game yet.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
